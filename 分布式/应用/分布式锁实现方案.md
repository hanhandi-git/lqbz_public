单体时代，可以直接用本地锁来实现对竞争资源的加锁，分布式环境下就要用到分布式锁。

常见方案有四种：

1、mysql分布式锁

2、zookeeper分布式锁

3、redis分布式锁

4、etcd分布式锁



## mysql分布式锁方案

创建一张锁表，数据库对字段做唯一性约束。

加锁的时候，在锁表中增加一条记录，释放锁的时候删除记录即可。

如果有并发请求同时提交到数据库，数据库会保证只有一个请求能够得到锁。

这种属于数据库IO操作效率不高，而且频繁操作会增大数据库开销，因此这种凡是在高并发、高性能的场景中用的不多



## zookeeper分布式锁方案

zookeeper的数据节点和文件目录类似，例如有一个lock节点，在此节点下建立子节点是可以保证先后顺序的，即使是两个进程同时申请新建节点，也会按照先后顺序建立两个节点。

![](https://secure2.wostatic.cn/static/4F5CZRn1FSLf8nC1JfgWWM/image.png?auth_key=1732170708-oncSNPuJhZNTwVdnbAsxhp-0-4255a6c51e7b3b6f151f9ab9cf34cac3)

所以可以以某个资源为目录，然后在这个目录下面的节点就是我们要获取锁的客户端，每个服务在目录下创建节点。如果它的节点序号在目录下最小，那么就能获得锁，否则等待。

释放锁就是删除服务创建的节点。

zk是一个逻辑比较中的分布式组件，实际上应用没那么多，所以用ZK实现分布式锁相对较少



## redis分布式锁方案

redis实现分布式锁，是当前应用最广泛的分布式锁实现方式。

redis执行命令是单线程的，redis实现分布式锁就是利用这个特性。

实现分布式锁最简单命令：

```C++
setNx(set if not exist)
```

如果不存在则更新：

```C++
setNx resourceName value
```

加锁了之后如果机器宕机，那这个锁就无法释放，所以需要加入过期时间，而且过期时间需要和setNx同一个原子操作，在redis2.8之前需要用lua脚本，redis2.8之后支持nx 和 ex操作都是同一原子操作。

```C++
set resourceName value ex 5 nx
```

一般生产中，都使用的redission客户端，良好封装了分布式锁的api，而且支持redlock。

## etcd分布式锁方案

etcd分布式锁的实现细节如下：

具体demo见：

利用etcd实现分布式锁

1、创建临时节点：etcd分布式锁的实现依赖于etcd的临时节点特性。当一个客户端创建一个临时节点时，如果该客户端断开连接或者崩溃，etcd会自动删除该节点

2、乐观锁：etcd分布式锁实现使用了乐观锁的思想。当一个客户端尝试获取锁时，它会创建一个临时节点，并将该节点的名称保存在一个共享数据结构中。如果该节点的名称是当前共享数据结构中的最小值，则客户端获取到了锁，否则，该客户端需要等待其他客户端释放锁

3、心跳机制：当一个客户端获取到锁时，它需要定期发送心跳消息，以保持锁的持有状态，如果该客户端崩溃或者断开连接。etcd会自动删除该客户端创建的临时节点，其他客户端可以获取到锁

4、重试机制：当一个客户端尝试获取锁时，如果锁已经被其他客户端持有，则该客户端会等待一段时间后重试。

操作步骤：

创建etcd客户端连接：首先需要创建一个etcd客户端连接，连接到etcd集群中的一个节点。

创建锁：使用etcd客户端创建一个锁，指定锁的名称和过期时间。锁的名称可以是任意字符串，过期时间是一个持续时间，表示锁的最长持有时间。

尝试获取锁：使用etcd客户端尝试获取锁，如果锁已经被其他客户端持有，则当前客户端会等待直到锁被释放或者超时。

操作共享资源：获取到锁之后，可以对共享资源进行操作，例如读取或者修改数据。

释放锁：操作完成之后，使用etcd客户端释放锁，让其他客户端可以获取到锁。