# 合并有序链表

## 问题链接
[LeetCode 21. 合并两个有序链表](https://leetcode.com/problems/merge-two-sorted-lists/)

## 问题描述
将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

## 解题思路
1. 使用迭代方法来解决这个问题。
2. 创建一个哑节点（dummy node）作为结果链表的头部。
3. 比较两个链表的当前节点，将较小的节点添加到结果链表中，并移动该链表的指针。
4. 重复步骤3，直到其中一个链表被遍历完。
5. 将剩余链表的节点直接接到结果链表的末尾。

## 代码实现
```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        ListNode* dummy = new ListNode(0);
        ListNode* current = dummy;
        
        while (l1 != nullptr && l2 != nullptr) {
            if (l1->val <= l2->val) {
                current->next = l1;
                l1 = l1->next;
            } else {
                current->next = l2;
                l2 = l2->next;
            }
            current = current->next;
        }
        
        if (l1 != nullptr) {
            current->next = l1;
        }
        if (l2 != nullptr) {
            current->next = l2;
        }
        
        return dummy->next;
    }
};
```

## 复杂度分析
- 时间复杂度：O(n + m)，其中n和m分别是两个链表的长度。
- 空间复杂度：O(1)，只使用了常数额外空间。

## 扩展：其他相关问题

### 1. 合并K个升序链表

问题描述：合并 k 个升序链表，返回合并后的升序链表。

例子：
```
输入：lists = [[1,4,5],[1,3,4],[2,6]]
输出：[1,1,2,3,4,4,5,6]
```

解题思路：
* 可以使用优先队列（最小堆）来实现。
优先队列（最小堆）的实现方法主要基于以下思路：
创建一个最小堆，用于存储链表的头节点。
将所有链表的头节点加入优先队列。
每次从优先队列中取出最小的节点，将其加入结果链表。
如果被取出的节点还有下一个节点，将下一个节点加入优先队列。
重复步骤3和4，直到优先队列为空。

* 或者可以使用分治法，两两合并链表。
归并实现的优点和特点
工作原理：
- 将K个链表分成两半
- 递归地合并左半部分和右半部分
- 最后合并得到的两个有序链表
- 基本操作是两个链表的合并（mergeTwoLists）
时间复杂度分析：
总共进行 log k 轮合并
每轮合并的时间复杂度是 O(N)，其中N是所有节点的总数
总时间复杂度：O(N log k)，与堆实现相同
空间复杂度：
O(log k)，来自递归调用栈的深度
相比堆实现（O(k)），空间复杂度更优
适用场景：
* 当K较小时，两种方法差异不大
* 当内存受限时，归并实现更优
* 当需要流式处理（边输入边合并）时，堆实现更优
这两种方法（堆和归并）的时间复杂度相同，但在不同场景下各有优势。选择哪种方法主要取决于具体的应用场景和限制条件。
### 2. 排序链表

问题描述：给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。

例子：
```
输入：head = [4,2,1,3]
输出：[1,2,3,4]
```

解题思路：
* 可以使用归并排序的思想。
* 首先找到链表中点，然后递归地对左右两半进行排序，最后合并两个有序链表。

### 3. 两数相加

问题描述：给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。请你将两个数相加，并以相同形式返回一个表示和的链表。

例子：
```
输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,8]
解释：342 + 465 = 807.
```

解题思路：
* 同时遍历两个链表，逐位相加。
* 注意处理进位情况。
* 如果其中一个链表较长，需要继续遍历剩余部分。

这些问题都涉及到链表的操作和合并，展示了如何在各种场景下处理链表结构。合并有序链表的思想可以应用到更复杂的问题中，如合并K个有序链表或者在链表上进行排序操作。
