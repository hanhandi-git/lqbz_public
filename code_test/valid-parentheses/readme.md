# 有效的括号

## 问题链接
[LeetCode 20. 有效的括号](https://leetcode.com/problems/valid-parentheses/)

## 问题描述
给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。

有效字符串需满足：
1. 左括号必须用相同类型的右括号闭合。
2. 左括号必须以正确的顺序闭合。
3. 每个右括号都有一个对应的相同类型的左括号。

## 解题思路
1. 使用栈来解决这个问题：
   - 遇到左括号时，将其压入栈中
   - 遇到右括号时，检查栈顶元素是否为对应的左括号   
   - 如果栈为空或栈顶元素不匹配，则字符串无效
   - 最后栈应该为空

2. 关键点：
   - 使用哈希表存储括号对的映射关系
   - 注意处理空字符串和奇数长度字符串的情况
   - 确保最后栈为空

## 代码实现
```cpp
class Solution {
public:
    bool isValid(string s) {
        stack<char> st;
        unordered_map<char, char> pairs = {
            {')', '('},
            {']', '['},
            {'}', '{'}
        };
        
        for (char c : s) {
            // 如果是右括号
            if (pairs.count(c)) {
                // 如果栈为空或栈顶元素不匹配
                if (st.empty() || st.top() != pairs[c]) {
                    return false;
                }
                st.pop();
            } else {
                // 如果是左括号，入栈
                st.push(c);
            }
        }
        
        // 最后栈应该为空
        return st.empty();
    }
};
```

## 复杂度分析
- 时间复杂度：O(n)，其中 n 是字符串的长度
- 空间复杂度：O(n)，在最坏情况下，栈的大小与字符串长度相同

## 扩展：相关问题
1. 最长有效括号
2. 括号生成
3. 删除无效的括号

## 扩展问题详解

### 1. 最长有效括号
#### 问题链接
[LeetCode 32. 最长有效括号](https://leetcode.com/problems/longest-valid-parentheses/)

#### 问题描述
给你一个只包含 '(' 和 ')' 的字符串，找出最长有效（格式正确且连续）括号子串的长度。

示例：
```
输入：s = "(()"
输出：2
解释：最长有效括号子串是 "()"

输入：s = ")()())"
输出：4
解释：最长有效括号子串是 "()()"
```

#### 解题思路
- 使用动态规划或栈来解决
- 记录每个位置结尾的最长有效括号长度

这个算法的关键点如下：
1. 栈的使用方式：
* 栈中存储的是字符的下标，而不是字符本身
* 初始化时压入-1作为特殊标记，这个很重要
2. 处理左括号的情况
```cpp
if (s[i] == '(') {
    st.push(i);  // 直接将下标压入栈
}
```
- 遇到左括号时，简单地将其下标压入栈
3. 处理右括号的情况：
```cpp
else { // s[i] == ')'
    st.pop();  // 先弹出栈顶
    if (st.empty()) {
        st.push(i);  // 如果栈空，将当前右括号的下标压入
    } else {
        maxLen = max(maxLen, i - st.top());  // 计算当前有效括号串的长度
    }
}
```
处理右括号时有两种情况：
情况1: 弹出后栈空
* 说明这个右括号没有匹配的左括号
* 将其下标压入栈，作为新的参考点
情况2: 弹出后栈非空
* 说明找到了一个匹配
* 用当前位置减去新的栈顶位置，得到有效括号串的长度

关键点：
- 栈顶元素始终记录的是"最后一个没有被匹配的右括号的位置"或者"上一个有效括号串的前一个位置"
- 当遇到不能匹配的右括号时，它会成为新的参考点
- 通过当前位置减去栈顶位置，我们可以得到当前有效括号串的长度
```cpp
class Solution {
public:
    int longestValidParentheses(string s) {
        stack<int> st;
        // 初始化时压入-1作为特殊标记
        // -1作为一个虚拟的起始点，用于计算第一个有效括号串的长度
        // 考虑字符串 "()"：
        // 初始：栈=[-1]
        // i=0, '(': 栈=[-1,0]
        // i=1, ')': 先pop()得到栈=[-1]，然后计算长度：1-(-1)=2
        st.push(-1);
        int maxLen = 0;
        
        for (int i = 0; i < s.length(); i++) {
            if (s[i] == '(') {
                st.push(i);  // 左括号：将下标压入栈
            } else {  // 遇到右括号')'
                // 初始：栈=[-1]
                // i=0, '(': 栈=[-1,0]
                // i=1, '(': 栈=[-1,0,1]
                // i=2, ')': pop()后栈=[-1,0]，计算长度：2-0=2
                // i=3, ')': pop()后栈=[-1]，计算长度：3-(-1)=4
                // op()是为了移除匹配的左括号，这样才能通过与新的栈顶的距离来计算有效括号串的长度
                // 先弹出栈顶元素（可能是左括号的下标，或者是上一个无效右括号的位置）
                st.pop();
                if (st.empty()) {
                    // 如果栈空了，说明这个右括号没有匹配的左括号
                    // 将其作为新的参考点
                    st.push(i);
                } else {
                    // 如果栈非空，说明找到了一个匹配
                    // 当前有效括号串的长度 = 当前位置 - 新的栈顶位置
                    maxLen = max(maxLen, i - st.top());
                }
            }
        }
        
        return maxLen;
    }
};
```

### 2. 括号生成
#### 问题链接
[LeetCode 22. 括号生成](https://leetcode.com/problems/generate-parentheses/)

#### 问题描述
数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。

示例：
```
输入：n = 3
输出：["((()))","(()())","(())()","()(())","()()()"]

输入：n = 1
输出：["()"]
```

#### 解题思路
- 使用回溯法生成所有可能的括号组合
- 保证左括号数量大于等于右括号数量
通过两个计数器(open和close来确保生成的括号组合是有效的)
添加括号的规则
* 如果左括号数量小于n，可以添加左括号
* 如果右括号小于左括号数量，可以添加右括号

```cpp
class Solution {
public:
    // 生成所有可能的有效括号组合
    // 参数 n: 需要生成的括号对数
    // 返回值: 包含所有有效括号组合的字符串数组
    vector<string> generateParenthesis(int n) {
        vector<string> result;
        backtrack(result, "", 0, 0, n);
        return result;
    }
    
private:
    // 回溯函数，用于生成有效的括号组合
    // 参数说明:
    // result: 存储所有有效组合的结果数组
    // current: 当前正在构建的括号字符串
    // open: 当前已使用的左括号数量
    // close: 当前已使用的右括号数量
    // max: 需要生成的括号对数（最大数量）
    void backtrack(vector<string>& result, string current, int open, int close, int max) {
        // 终止条件：当前字符串长度等于括号对数的两倍（每对括号需要两个字符）
        if (current.length() == max * 2) {
            result.push_back(current);
            return;
        }
        // 可以添加左括号的条件：已使用的左括号数量小于最大值
        if (open < max) {
            // 添加左括号，并继续递归
            backtrack(result, current + "(", open + 1, close, max);
        }
        // 可以添加右括号的条件：已使用的右括号数量小于已使用的左括号数量
        // 这确保了括号组合的有效性
        if (close < open) {
            // 添加右括号，并继续递归
            backtrack(result, current + ")", open, close + 1, max);
        }
    }
};
```

### 3. 删除无效的括号
#### 问题链接
[LeetCode 301. 删除无效的括号](https://leetcode.com/problems/remove-invalid-parentheses/)

#### 问题描述
给你一个由若干括号和字母组成的字符串 s ，删除最小数量的无效括号，使得输入的字符串有效。

返回所有可能的结果。答案可以按 任意顺序 返回。

示例：
```
输入：s = "()())()"
输出：["(())()","()()()"]

输入：s = "(a)())()"
输出：["(a())()","(a)()()"]

输入：s = ")("
输出：[""]
```

注意：
- 返回的字符串需要满足有效括号的所有要求
- 需要删除最少数量的括号
- 如果字符串已经是有效的，则不需要删除任何字符

#### 解题思路
#### 解题思路
1. 首先统计需要删除的左括号和右括号的数量：
   - 遍历字符串，遇到左括号'('时，left计数加1
   - 遇到右括号')'时，如果前面有未匹配的左括号(left>0)，则left减1；否则right计数加1
   
2. 使用DFS回溯法删除括号：
   - 每次可以选择删除一个左括号或右括号
   - 为了避免重复结果，对连续相同的括号只处理第一个
   - 当需要删除的左右括号数量都为0时，检查当前字符串是否有效

3. 判断字符串是否有效的方法：
   - 使用计数器，遇到左括号加1，右括号减1
   - 过程中如果计数小于0，说明右括号多了，返回false
   - 最后计数为0说明括号完全匹配

让我详细解释一下计算需要删除的左右括号数量的逻辑：
假设我们有一个字符串 "())"，我们一步步分析：
对于左括号'('的处理：
每遇到一个左括号，先将left++
这是因为我们还不知道后面是否有右括号与之匹配
对于右括号')'的处理：
当遇到右括号时，我们要判断前面是否有未匹配的左括号（即left>0）
如果有未匹配的左括号(left>0)，说明这个右括号可以和前面的某个左括号匹配，所以left--
如果没有未匹配的左括号(left=0)，说明这个右括号是多余的，必须被删除，所以right++
举例说明：
s = "())"
1. 遇到'('：left = 1
2. 遇到')'：发现left>0，说明可以匹配，left--，此时left = 0
3. 遇到')'：发现left=0，说明没有左括号可以匹配，right++，此时right = 1
最终结果：left = 0, right = 1，表示需要删除1个右括号
再看一个复杂例子：
s = "(()"
1. 遇到'('：left = 1
2. 遇到'('：left = 2
3. 遇到')'：发现left>0，可以匹配，left--，此时left = 1
遍历结束后，left = 1，表示还有1个左括号未匹配，需要删除
所以这个计算过程实际上是在：
统计不能被匹配的右括号数量（right变量）
统计剩余未被匹配的左括号数量（left变量）
这两个数字就是我们最少需要删除的括号数量，才能使字符串变得合法。
```cpp
class Solution {
public:
    vector<string> removeInvalidParentheses(string s) {
        vector<string> result;
        int left = 0, right = 0;
        
        // 第一次遍历：计算需要删除的左右括号数量
        for (char c : s) {
            if (c == '(') {
                left++;  // 遇到左括号，计数加1
            } else if (c == ')') {
                if (left > 0) {
                    left--;  // 如果有未匹配的左括号，left减1
                } else {
                    right++;  // 否则需要删除的右括号数量加1
                }
            }
        }
        
        dfs(s, 0, left, right, result);
        return result;
    }
    
private:
    void dfs(string s, int start, int left, int right, vector<string>& result) {
        // 当左右括号都不需要删除时，检查字符串是否有效
        if (left == 0 && right == 0) {
            if (isValid(s)) {
                result.push_back(s);
            }
            return;
        }
        
        // 从start开始遍历，尝试删除括号
        for (int i = start; i < s.length(); i++) {
            // 跳过重复的括号，避免产生重复的结果
            if (i > start && s[i] == s[i-1]) continue;
            
            // 如果需要删除右括号且当前是右括号
            if (right > 0 && s[i] == ')') {
                string next = s.substr(0, i) + s.substr(i + 1);  // 删除当前右括号
                dfs(next, i, left, right - 1, result);
            } 
            // 如果需要删除左括号且当前是左括号
            else if (left > 0 && s[i] == '(') {
                string next = s.substr(0, i) + s.substr(i + 1);  // 删除当前左括号
                dfs(next, i, left - 1, right, result);
            }
        }
    }
    
    // 检查字符串是否是有效的括号组合
    bool isValid(string s) {
        int count = 0;  // 使用计数器记录括号匹配情况
        for (char c : s) {
            if (c == '(') count++;  // 左括号计数加1
            if (c == ')') count--;  // 右括号计数减1
            if (count < 0) return false;  // 如果右括号多于左括号，无效
        }
        return count == 0;  // 最终左右括号数量相等才有效
    }
};

### 总结
括号相关问题是算法中的经典问题，主要有以下几个要点：

1. 基本的栈解法：用于验证括号的有效性
2. 动态规划：解决最长有效括号等问题
3. 回溯法：用于生成所有可能的有效括号组合
4. BFS/DFS：处理需要删除括号的复杂情况

掌握这些问题有助于理解栈、动态规划和回溯等重要的算法思想，同时也能加深对字符串处理的理解。
