# 接雨水

## 问题链接
[LeetCode 42. 接雨水](https://leetcode.com/problems/trapping-rain-water/)

## 问题描述
给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

### 一维接雨水图解
```
示例 1: height = [0,1,0,2,1,0,1,3,2,1,2,1]

按高度绘制的柱状图：
                     __
         __         |  |
   __    |  |__    |  |__    __
__|  |__ |     |__ |     |__|  |__
[0,1,0,2,1,0,1,3,2,1,2,1]

积水后的状态（~表示水）：
                     __
         __    ~    |  |
   __    |  |__    |  |__    __
__|  |__ |     |__ |     |__|  |__
[0,1,0,2,1,0,1,3,2,1,2,1]

计算过程：
位置 2: 可以存储 1 单位水
位置 5: 可以存储 2 单位水
位置 6: 可以存储 1 单位水
位置 9: 可以存储 1 单位水
位置 10: 可以存储 1 单位水
总计: 6 单位水
```

```
示例 2: height = [4,2,0,3,2,5]

按高度绘制的柱状图：
            __
__          |  |
|  |    __  |  |
|  |    |  ||  |
|  |__  |  ||  |
[4,2,0,3,2,5]

积水后的状态（~表示水）：
            __
__    ~  ~  |  |
|  |  ~ __  |  |
|  |~ ~|  | |  |
|  |__|  |_|  |
[4,2,0,3,2,5]

计算过程：
位置 2: 可以存储 2 单位水
位置 3: 可以存储 1 单位水
位置 4: 可以存储 2 单位水
总计: 9 单位水
```

### 二维接雨水图解（太平洋大西洋水流）
```
示例: heights = 
[[1,2,2,3,5],
 [3,2,3,4,4],
 [2,4,5,3,1],
 [6,7,1,4,5],
 [5,1,1,2,4]]

图形表示（数字表示高度，箭头表示水流方向）：
太平洋
↓↓↓↓↓
→1 2 2 3 5←
→3 2 3 4 4←
→2 4 5 3 1←
→6 7 1 4 5←
→5 1 1 2 4←
↑↑↑↑↑
大西洋

可以流向两个海洋的点（标记为*）：
  * *
   *
* *
*

结果坐标：[[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]
```

### 三维接雨水图解
```
示例: heightMap = 
[[1,4,3,1,3,2],
 [3,2,1,3,2,4],
 [2,3,3,2,3,1]]

3D表示（数字表示高度，~表示积水）：
俯视图：
  1 4 3 1 3 2
  3 2 1 3 2 4
  2 3 3 2 3 1

积水后（~表示水）：
  1 4 3 1 3 2
  3 2~2~3 2 4
  2 3 3 2 3 1

计算说明：
1. 边界形成了一个"围墙"
2. 内部低洼处可以积水
3. 水位由周围最低的"围墙"决定
4. 总计可以积 4 单位的水
```

## 解题思路
这道题有多种解法，每种解法都有其独特的思维角度和实现方式。让我们深入分析每种方法：

### 1. 动态规划法
#### 核心思想
- 对于每个位置i，能接的雨水量取决于两个因素：
  1. 左边最高的柱子高度leftMax[i]
  2. 右边最高的柱子高度rightMax[i]
- 该位置能接的雨水量 = min(leftMax[i], rightMax[i]) - height[i]

#### 实现步骤
1. 预处理得到每个位置左右两侧的最大高度：
   ```
   对于位置i：
   leftMax[i] = max(leftMax[i-1], height[i])
   rightMax[i] = max(rightMax[i+1], height[i])
   ```

2. 遍历每个位置计算可以接的雨水量：
   ```
   对于每个位置i：
   water[i] = min(leftMax[i], rightMax[i]) - height[i]
   ```

#### 图解分析
```
示例：height = [0,1,0,2,1,0,1,3,2,1,2,1]

1. 计算leftMax数组：
位置:    0  1  2  3  4  5  6  7  8  9  10 11
height:  0  1  0  2  1  0  1  3  2  1  2  1
leftMax: 0  1  1  2  2  2  2  3  3  3  3  3

2. 计算rightMax数组：
位置:     0  1  2  3  4  5  6  7  8  9  10 11
height:   0  1  0  2  1  0  1  3  2  1  2  1
rightMax: 3  3  3  3  3  3  3  3  2  2  2  1

3. 计算每个位置能接的水量：
位置i=2为例：
- leftMax[2] = 1
- rightMax[2] = 3
- height[2] = 0
- water[2] = min(1,3) - 0 = 1
```

### 2. 双指针法
#### 核心思想
- 使用左右两个指针从两端向中间移动
- 维护左右两侧已遍历部分的最大高度
- 根据较小的一侧来计算当前位置能接的水量

#### 实现步骤
1. 初始化左右指针和左右最大高度：
   ```
   left = 0, right = n-1
   leftMax = rightMax = 0
   ```

2. 当left < right时：
   - 如果height[left] < height[right]：
     * 如果height[left] >= leftMax，更新leftMax
     * 否则可以接水：water += leftMax - height[left]
     * left++
   - 否则：
     * 如果height[right] >= rightMax，更新rightMax
     * 否则可以接水：water += rightMax - height[right]
     * right--

#### 图解分析
```
示例：height = [0,1,0,2,1,0,1,3,2,1,2,1]

初始状态：
left=0, right=11
leftMax=0, rightMax=0

步骤1：
height[0]=0 < height[11]=1
water += 0-0 = 0
leftMax = 0
left++

步骤2：
height[1]=1 < height[11]=1
leftMax = 1
left++

... 以此类推
```

### 3. 单调栈法
#### 核心思想
- 使用栈维护一个单调递减的高度序列
- 当遇到一个较大的高度时，说明找到了一个可能的凹槽
- 计算凹槽能接的雨水量 = 凹槽宽度 * (min(左边界高度,右边界高度) - 凹槽底部高度)

#### 实现步骤
1. 维护单调栈：
   - 当前高度小于等于栈顶高度时，入栈
   - 当前高度大于栈顶高度时，说明找到了一个凹槽

2. 处理凹槽：
   - 弹出栈顶元素，这是凹槽的底部
   - 计算左右边界（当前元素和新的栈顶元素）
   - 计算这个凹槽能接的水量

#### 图解分析
```
示例：height = [0,1,0,2,1,0,1,3,2,1,2,1]

步骤1：遍历到height[0]=0
栈：[0]

步骤2：遍历到height[1]=1
1 > 0，找到凹槽
栈：[1]

步骤3：遍历到height[2]=0
0 < 1，入栈
栈：[1,2]

步骤4：遍历到height[3]=2
2 > 0，找到凹槽
计算位置2的积水量：min(1,2)-0 = 1
栈：[3]

... 以此类推
```

### 算法选择建议
1. 如果对空间复杂度要求不严格：
   - 选择动态规划，代码直观易懂
   - 时间复杂度O(n)，空间复杂度O(n)

2. 如果要求优化空间复杂度：
   - 选择双指针法，可以实现O(1)空间复杂度
   - 时间复杂度仍然是O(n)

3. 如果需要处理类似的单调性问题：
   - 选择单调栈法，这种思维方式可以推广到其他问题
   - 时间复杂度O(n)，空间复杂度O(n)

## 代码实现

### 1. 动态规划解法
```cpp
class Solution {
public:
    int trap(vector<int>& height) {
        if (height.empty()) return 0;
        
        int n = height.size();
        vector<int> leftMax(n), rightMax(n);
        
        // 计算左侧最大高度
        leftMax[0] = height[0];
        for (int i = 1; i < n; i++) {
            leftMax[i] = max(leftMax[i-1], height[i]);
        }
        
        // 计算右侧最大高度
        rightMax[n-1] = height[n-1];
        for (int i = n-2; i >= 0; i--) {
            rightMax[i] = max(rightMax[i+1], height[i]);
        }
        
        // 计算接水量
        int water = 0;
        for (int i = 0; i < n; i++) {
            water += min(leftMax[i], rightMax[i]) - height[i];
        }
        
        return water;
    }
};
```

### 2. 双指针解法
```cpp
class Solution {
public:
    int trap(vector<int>& height) {
        int left = 0, right = height.size() - 1;
        int leftMax = 0, rightMax = 0;
        int water = 0;
        
        while (left < right) {
            if (height[left] < height[right]) {
                if (height[left] >= leftMax) {
                    leftMax = height[left];
                } else {
                    water += leftMax - height[left];
                }
                left++;
            } else {
                if (height[right] >= rightMax) {
                    rightMax = height[right];
                } else {
                    water += rightMax - height[right];
                }
                right--;
            }
        }
        
        return water;
    }
};
```

### 3. 单调栈解法
```cpp
class Solution {
public:
    int trap_stack(vector<int>& height) {
        // 单调栈存储的是下标，栈中下标对应的高度是单调递减的
        stack<int> st;
        int water = 0;
        
        // 遍历每个柱子
        for (int i = 0; i < height.size(); i++) {
            // 当栈不为空且当前柱子高度大于栈顶柱子高度时
            // 说明找到了一个可以接雨水的凹槽
            while (!st.empty() && height[i] > height[st.top()]) {
                // 取出凹槽底部的高度
                int top = st.top();
                st.pop();
                
                // 如果栈为空，说明左边没有柱子了，无法接水
                if (st.empty()) break;
                
                // 计算凹槽的宽度：当前柱子下标 - 左边柱子下标 - 1
                int distance = i - st.top() - 1;
                // 计算凹槽的高度：两边柱子的最小高度 - 凹槽底部高度
                int bounded_height = min(height[i], height[st.top()]) - height[top];
                // 累加这个凹槽可以接的水量
                water += distance * bounded_height;
            }
            // 将当前柱子入栈，继续维护单调递减特性
            st.push(i);
        }
        
        return water;
    }
};
```

### 单调栈解法详解
单调栈解法的核心思想是维护一个单调递减的高度序列，通过栈来处理每个位置可能形成的凹槽。
1. 为什么要用单调栈
- 单调栈可以帮助我们找到左右两边第一个比当前高度高的柱子
- 这正是计算积水需要的信息

2. 栈内元素的含义
- 栈中存储的是下标而不是高度
- 栈中的元素对应的高度是单调递减的

3. 计算过程的关键步骤
- 当找到一个比栈顶元素高的柱子时,就可以计算积水
- 计算宽度和高度的方法
- 为什么要判断栈是否为空

4. 整体的思路流程
- 维护单调递减栈
- 当出现更高柱子时计算积水
- 最后剩余的递减序列不会有积水
#### 工作原理
1. **栈的维护**：
   - 栈中存储的是柱子的索引（而不是高度）
   - 保持栈中的柱子高度是单调递减的
   - 当遇到一个较高的柱子时，说明可能形成凹槽

2. **凹槽的形成**：
   ```
   当前柱子: i
   栈顶柱子（凹槽底部）: top
   次栈顶柱子（左边界）: st.top()
   右边界: 当前柱子i

        |
   |    |
   |  _ |   <- 当前位置i
   |_|  |   <- top（凹槽底部）
   ```

3. **积水量计算**：
   - 凹槽宽度 = 右边界位置 - 左边界位置 - 1
   - 凹槽高度 = min(左边界高度, 右边界高度) - 凹槽底部高度
   - 该凹槽积水量 = 宽度 * 高度

#### 示例分析
以输入 `[4,2,0,3,2,5]` 为例：
```
步骤1: 初始状态
4 |    |
3 |    |         |
2 |    |__    |  |
1 |    |  |   |  |
0 |____|__|___|__|
  [4,   2,  0,  3]  栈:[0]（索引）

步骤2: 遇到高度3
4 |    |
3 |    |    |      <- 可以接水
2 |    |__  |  
1 |    |  | |  
0 |____|__|_|__
  [4,   2,  0,  3]  栈:[0,1]

步骤3: 计算积水
- 凹槽底部(top) = 2
- 左边界 = 2
- 右边界 = 3
- 宽度 = 3 - 2 - 1 = 0
- 高度 = min(2, 3) - 0 = 2
- 积水量 = 0 * 2 = 2
```

#### 代码实现要点
```cpp
int trap_stack(vector<int>& height) {
    stack<int> st;  // 存储索引的栈
    int water = 0;
    
    for (int i = 0; i < height.size(); i++) {
        // 当前高度大于栈顶高度时，可能形成凹槽
        while (!st.empty() && height[i] > height[st.top()]) {
            int top = st.top();  // 凹槽底部
            st.pop();
            
            if (st.empty()) break;  // 没有左边界
            
            // 计算凹槽大小
            int distance = i - st.top() - 1;  // 宽度
            int bounded_height = min(height[i], height[st.top()]) - height[top];  // 高度
            water += distance * bounded_height;
        }
        st.push(i);
    }
    return water;
}
```

#### 优缺点分析
优点：
- 可以一次遍历就得到结果
- 适合处理需要找左右边界的问题
- 可以方便地处理多个凹槽的情况

缺点：
- 需要额外的栈空间
- 实现相对复杂
- 不如双指针解法直观

## 复杂度分析

### 动态规划解法
- 时间复杂度：O(n)，需要遍历数组三次
- 空间复杂度：O(n)，需要两个数组存储左右最大高度

### 双指针解法
- 时间复杂度：O(n)，只需要遍历一次数组
- 空间复杂度：O(1)，只需要常数空间

### 单调栈解法
- 时间复杂度：O(n)，每个元素最多被压入和弹出栈一次
- 空间复杂度：O(n)，栈的大小最大为n

## 解题技巧
1. 理解积水的条件：当前位置能积水的量取决于其左右两侧最大高度的较小值
2. 选择合适的解法：
   - 如果对空间要求不严格，可以使用动态规划
   - 如果要求空间复杂度为O(1)，使用双指针法
   - 如果需要处理类似的单调性问题，可以考虑单调栈

## 相关问题详解

### 1. 盛最多水的容器
#### 问题链接
[Container With Most Water](https://leetcode.com/problems/container-with-most-water/)

#### 问题描述
给定一个长度为 n 的整数数组 height，有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i])。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

示例：
```
输入：height = [1,8,6,2,5,4,8,3,7]
输出：49
解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水的最大值为 49。
```

#### 解题思路
- 使用双指针法，从数组两端向中间移动
- 容器的水量由较短的那条线决定
- 每次移动较短的那条线的指针，因为移动较长的线不可能得到更大的面积


这个问题与接雨水的区别在于：
1. 只需要找两个柱子，而不是计算所有凹槽
2. 水可以高于中间的柱子
3. 面积取决于较短的柱子和两柱子间的距离

示例分析：
```
输入：[1,8,6,2,5,4,8,3,7]

初始状态：
8 |   |           |
7 |   |           |     |
6 |   |   |       |     |
5 |   |   |   |   |     |
4 |   |   |   | | |     |
3 |   |   |   | | |  |  |
2 |   |   | | | | |  |  |
1 |   |   | | | | |  |  |
0 |___|___|_|_|_|_|__|__|
  [1,  8,  6,2,5,4,8, 3, 7]
   ^                      ^
  left                  right

面积 = min(1,7) * 8 = 8

最终最大面积：
在height[1]=8和height[8]=7之间
面积 = min(8,7) * 7 = 49
```

关键优化：为什么要移动较短的那条边？
- 因为面积受限于较短的边
- 移动较长的边，宽度减小，高度不可能增加
- 只有移动较短的边，才有可能得到更大的面积


```cpp
class Solution {
public:
    int maxArea(vector<int>& height) {
        int maxWater = 0;
        int left = 0, right = height.size() - 1;
        
        while (left < right) {
            int width = right - left;
            int h = min(height[left], height[right]);
            maxWater = max(maxWater, width * h);
            
            if (height[left] < height[right]) {
                left++;
            } else {
                right--;
            }
        }
        
        return maxWater;
    }
};
```

### 2. 除自身以外数组的乘积详解

#### 核心思路
这个问题的关键在于如何不使用除法，同时实现O(1)的额外空间复杂度。主要思路是：
1. 将结果分解为左侧所有数的乘积和右侧所有数的乘积
2. 使用输出数组作为临时存储空间，避免使用额外空间

#### 算法步骤详解
```
示例：nums = [1,2,3,4]

步骤1: 计算左侧乘积
初始：answer = [1,1,1,1]
处理过程：
- answer[0] = 1 (没有左侧元素)
- answer[1] = 1 * 1 = 1
- answer[2] = 1 * 2 = 2
- answer[3] = 2 * 3 = 6
此时：answer = [1,1,2,6]

步骤2: 计算右侧乘积并与左侧乘积相乘
rightProduct = 1
从右向左遍历：
- i=3: answer[3] = 6 * 1 = 6, rightProduct = 4
- i=2: answer[2] = 2 * 4 = 8, rightProduct = 12
- i=1: answer[1] = 1 * 12 = 12, rightProduct = 24
- i=0: answer[0] = 1 * 24 = 24

最终结果：[24,12,8,6]
```

#### 空间优化技巧
1. 使用输出数组存储左侧乘积
2. 使用一个变量存储右侧乘积
3. 在第二次遍历时同时完成乘法运算

#### 代码实现要点
```cpp
vector<int> productExceptSelf(vector<int>& nums) {
    int n = nums.size();
    vector<int> answer(n, 1);
    
    // 计算左侧乘积
    for (int i = 1; i < n; i++) {
        answer[i] = answer[i-1] * nums[i-1];
    }
    
    // 计算右侧乘积并与左侧乘积相乘
    int rightProduct = 1;
    for (int i = n-1; i >= 0; i--) {
        answer[i] *= rightProduct;
        rightProduct *= nums[i];
    }
    
    return answer;
}
```

#### 特殊情况处理
1. 数组中包含0的情况
```
输入：nums = [-1,1,0,-3,3]
分析：
- 如果数组中有一个0，那么除了0所在位置外，其他位置的结果都是0
- 如果数组中有多个0，那么所有位置的结果都是0
```

2. 数组中包含负数的情况
```
输入：nums = [-1,-1,2,-5,3]
分析：
- 需要考虑负数的个数的奇偶性
- 结果的符号取决于除自身外其他数的负数个数
```

### 3. 柱状图中最大的矩形详解

#### 问题本质
本质上是要找到每个柱子能够向左右扩展的最远距离，使得扩展区域内的所有柱子高度都不小于当前柱子的高度。

#### 单调栈解法详解
使用单调栈的原因：
1. 需要找到每个柱子左右两侧第一个比它矮的柱子
2. 单调栈可以在O(n)时间内完成这个任务

#### 算法步骤图解
```
示例：heights = [2,1,5,6,2,3]

步骤1: 初始状态
6 |           __
5 |        __|  |
4 |        |  |  |
3 |        |  |  |    __
2 |  __    |  |  |__ |  |
1 |  |  |__|  |  |  ||  |
0 |__|__|__|__|__|__|__|__
   [2, 1, 5, 6, 2, 3]

处理过程：
1) 遇到2: 入栈 [0]
2) 遇到1: 2>1，计算2的面积
   - 高度=2
   - 宽度=1
   - 面积=2
   入栈 [1]
3) 遇到5: 入栈 [1,2]
4) 遇到6: 入栈 [1,2,3]
5) 遇到2: 6>2，计算6和5的面积
   - 6的面积=6*1=6
   - 5的面积=5*2=10
   入栈 [1,4]
6) 遇到3: 入栈 [1,4,5]

最大面积为10（高度为5，宽度为2的矩形）
```

#### 代码实现要点
```cpp
int largestRectangleArea(vector<int>& heights) {
    // 添加哨兵，简化边界处理
    heights.push_back(0);
    stack<int> st;
    int maxArea = 0;
    
    for (int i = 0; i < heights.size(); i++) {
        // 当前高度小于栈顶高度时，计算栈顶柱子能够形成的最大矩形
        while (!st.empty() && heights[i] < heights[st.top()]) {
            int height = heights[st.top()];
            st.pop();
            
            // 计算宽度：当前位置到栈顶位置的距离
            int width = st.empty() ? i : i - st.top() - 1;
            maxArea = max(maxArea, height * width);
        }
        st.push(i);
    }
    
    return maxArea;
}
```

#### 优化技巧
1. 使用哨兵简化边界处理
   - 在数组末尾添加高度为0的柱子
   - 避免了栈为空的特殊处理

2. 宽度计算技巧
   ```
   当计算某个柱子i能形成的矩形面积时：
   - 右边界：当前遍历到的位置j（第一个比i矮的柱子）
   - 左边界：栈顶元素k（第一个比i矮的柱子）
   - 宽度 = j - k - 1
   ```

3. 特殊情况处理
   ```
   - 单调递增序列：[1,2,3,4,5]
   - 单调递减序列：[5,4,3,2,1]
   - 全部相等：[2,2,2,2]
   ```

#### 复杂度分析
- 时间复杂度：O(n)
  * 每个元素最多入栈和出栈一次
  * 计算面积的操作是常数时间
- 空间复杂度：O(n)
  * 栈在最坏情况下可能存储所有元素（单调递增序列）

这些扩展问题展示了如何使用不同的数据结构和算法技巧来解决看似复杂的问题。理解这些问题的解法对于掌握数组操作、动态规划、单调栈等重要的算法思想非常有帮助。

## 接雨水的维度扩展

### 1. 二维接雨水
#### 问题链接
[LeetCode 417. 太平洋大西洋水流问题](https://leetcode.com/problems/pacific-atlantic-water-flow/)

#### 问题描述
给定一个 m × n 的矩阵，其中的值表示地形高度。在这个地形中，"太平洋"处于大陆的左边界和上边界，而"大西洋"处于大陆的右边界和下边界。规定水流只能从高处流到低处或者在同等高度上流动。请找出那些水流既可以流动到"太平洋"，又能流动到"大西洋"的陆地单元的坐标。

示例：
```
输入: heights = 
[[1,2,2,3,5],
 [3,2,3,4,4],
 [2,4,5,3,1],
 [6,7,1,4,5],
 [5,1,1,2,4]]
输出: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]
```

#### 解题思路
- 这是一个反向思维的问题：不是直接寻找可以流向两个海洋的点，而是从海洋边界反向寻找
- 分别从太平洋和大西洋的边界开始，找出水可以流到的所有点
- 最后取两个集合的交集，就是答案

#### 实现步骤
1. 初始化：
   ```
   - 创建两个visited数组，分别记录可以流向太平洋和大西洋的点
   - 将太平洋边界（左边界和上边界）加入太平洋的DFS起点
   - 将大西洋边界（右边界和下边界）加入大西洋的DFS起点
   ```

2. DFS搜索过程：
   ```
   - 从边界开始，向四个方向搜索
   - 只有当下一个点的高度大于等于当前点时，水才能从下一个点流到当前点
   - 标记所有可以流到当前海洋的点
   ```

3. 寻找交集：
   ```
   - 遍历矩阵中的每个点
   - 如果一个点既可以流向太平洋又可以流向大西洋，就是答案点
   ```

#### 图解分析
```
示例矩阵：
[[1,2,2,3,5],
 [3,2,3,4,4],
 [2,4,5,3,1],
 [6,7,1,4,5],
 [5,1,1,2,4]]

1. 从太平洋边界开始DFS（P表示可以流向太平洋的点）：
P P P P P
P P P P P
P P P - -
P P - - -
P - - - -

2. 从大西洋边界开始DFS（A表示可以流向大西洋的点）：
- - - - A
- - - A A
- - A A A
A A A A A
A A A A A

3. 找出交集点（*表示既可以流向太平洋又可以流向大西洋的点）：
- - - - *
- - - * *
- - * - -
* * - - -
* - - - -
```

#### 代码实现要点
```cpp
// 关键点1：DFS的方向是从低处到高处
// 因为我们是反向思维：如果水能从高处流到低处，那么我们从低处DFS到高处就是合法的路径
if (heights[ni][nj] >= heights[i][j]) {
    dfs(heights, visited, ni, nj, m, n);
}

// 关键点2：两次独立的DFS，分别标记可以流向每个海洋的点
for (int i = 0; i < m; i++) {
    dfs(heights, pacific, i, 0, m, n);      // 左边界
    dfs(heights, atlantic, i, n-1, m, n);   // 右边界
}
for (int j = 0; j < n; j++) {
    dfs(heights, pacific, 0, j, m, n);      // 上边界
    dfs(heights, atlantic, m-1, j, m, n);   // 下边界
}
```

### 2. 三维接雨水
#### 问题链接
[LeetCode 407. 接雨水 II](https://leetcode.com/problems/trapping-rain-water-ii/)

#### 问题描述
给一个 m x n 的矩阵，其中的值表示每个单元的高度，请计算按此排列的柱子，下雨之后能接多少雨水。

示例：
```
输入: heightMap = 
[[1,4,3,1,3,2],
 [3,2,1,3,2,4],
 [2,3,3,2,3,1]]
输出: 4
解释: 下雨后，雨水将会被上图蓝色的方块中的洼地接住，总的接水量为4。
```

#### 解题思路
- 类似于木桶原理：一个位置能接的水量取决于它周围最低的"围墙"高度
- 使用优先队列维护当前"围墙"的边界，从最低的边界开始处理
- 从外向内"灌水"，保证每个位置的水位不会超过它周围的最小高度

#### 实现步骤
1. 初始化边界：
   ```
   - 将矩阵的边界元素都加入优先队列
   - 标记这些边界元素为已访问
   - 优先队列按高度排序，保证从最低的边界开始处理
   ```

2. 处理内部单元格：
   ```
   - 每次从优先队列取出最低的边界点
   - 更新当前的最大水位（木桶的最低边界）
   - 向四个方向扩展，寻找新的可能的积水点
   ```

3. 计算积水量：
   ```
   - 对于每个新访问的点，如果它的高度小于当前最大水位
   - 则这个点可以积水：water += maxHeight - height[i][j]
   - 将这个点加入优先队列，成为新的边界
   ```

#### 图解分析
```
示例：
[[1,4,3,1,3,2],
 [3,2,1,3,2,4],
 [2,3,3,2,3,1]]

处理过程：
1. 初始状态（边界标记为B）：
B B B B B B
B - - - - B
B B B B B B

2. 从最低的边界开始处理（数字表示当前水位）：
1 4 3 1 3 2
3 2 2 3 2 4    <- 中间的1被填充到2（由周围的最低边界决定）
2 3 3 2 3 1

3. 最终积水状态（~表示水）：
1 4 3 1 3 2
3 2~2~3 2 4    <- 积水2-1=1和2-1=1，共2个单位
2 3 3 2 3 1
```

#### 优先队列的作用
1. 维护边界：
   - 优先队列中存储的是当前"木桶"的边界点
   - 按高度排序，保证从最低的边界开始处理

2. 保证水位正确：
   ```cpp
   // 更新最大水位
   maxHeight = max(maxHeight, height);
   
   // 如果新点比当前水位低，可以积水
   if (heightMap[ni][nj] < maxHeight) {
       water += maxHeight - heightMap[ni][nj];
   }
   ```

3. 动态边界：
   - 处理完一个边界点后，它的相邻点会成为新的边界
   - 这些新边界点被加入优先队列，保持边界的连续性

#### 复杂度分析
- 时间复杂度：O(mn * log(mn))
  * 每个单元格最多入队一次
  * 优先队列的操作是log(mn)
- 空间复杂度：O(mn)
  * visited数组和优先队列的空间
### 维度扩展的比较
1. **一维接雨水**
   - 只需考虑左右两侧的最大高度
   - 可以使用双指针实现O(1)空间复杂度
   - 相对简单直观

2. **二维接雨水（太平洋大西洋水流）**
   - 需要考虑四个方向的水流
   - 可以使用DFS或BFS解决
   - 重点在于从边界开始反向思考

3. **三维接雨水**
   - 最复杂的版本，需要考虑所有方向
   - 使用优先队列处理边界
   - 类似于"木桶原理"，水位由最低点决定

### 解题技巧对比
1. **数据结构选择**
   - 一维：数组、栈
   - 二维：DFS/BFS访问数组
   - 三维：优先队列（最小堆）

2. **算法思想**
   - 一维：双指针、单调栈
   - 二维：图搜索（DFS/BFS）
   - 三维：贪心 + 优先队列

3. **复杂度分析**
   - 一维：O(n) 时间，O(1) 空间（双指针方法）
   - 二维：O(mn) 时间，O(mn) 空间
   - 三维：O(mn*log(mn)) 时间，O(mn) 空间
这些维度扩展不仅加深了我们对原问题的理解，也展示了如何将基本问题推广到更复杂的场景。掌握这些变体有助于提高解决复杂问题的能力。