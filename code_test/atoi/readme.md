## 问题链接
[LeetCode - 字符串转换整数 (atoi)](https://leetcode.cn/problems/string-to-integer-atoi/)

## 问题描述
请你来实现一个 `myAtoi(string s)` 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。

函数 `myAtoi(string s)` 的算法如下：

1. 读入字符串并丢弃无用的前导空格
2. 检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。
3. 读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。
4. 将前面步骤读入的这些数字转换为整数（即，"123" -> 123， "0032" -> 32）。如果没有读入数字，则整数为 0。
5. 如果整数数超过 32 位有符号整数范围 [−2^31, 2^31 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −2^31 的整数应该被固定为 −2^31 ，大于 2^31 − 1 的整数应该被固定为 2^31 − 1 。
6. 返回整数作为最终结果。

### 示例 1：
输入：s = "42"
输出：42
解释：加粗的字符串为已经读入的字符，插入符号是当前读取的字符。
第 1 步："42"（当前没有读入字符，因为没有前导空格）
第 2 步："42"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）
第 3 步："42"（读入 "42"）
解析得到整数 42 。
由于 "42" 在范围 [-2^31, 2^31 - 1] 内，最终结果为 42 。

### 示例 2：
输入：s = "   -42"
输出：-42
解释：
第 1 步："   -42"（读入前导空格，但忽视掉）
第 2 步："   -42"（读入 '-' 字符，所以结果应该是负数）
第 3 步："   -42"（读入 "42"）
解析得到整数 -42 。
由于 "-42" 在范围 [-2^31, 2^31 - 1] 内，最终结果为 -42 。

### 示例 3：
输入：s = "4193 with words"
输出：4193
解释：
第 1 步："4193 with words"（当前没有读入字符，因为没有前导空格）
第 2 步："4193 with words"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）
第 3 步："4193 with words"（读入 "4193"；由于下一个字符不是一个数字，所以读入停止）
解析得到整数 4193 。
由于 "4193" 在范围 [-2^31, 2^31 - 1] 内，最终结果为 4193 。

### 提示：
- 0 <= s.length <= 200
- s 由英文字母（大写和小写）、数字（0-9）、' '、'+'、'-' 和 '.' 组成

## 解题思路

### 1. 基本思路
- 这是一个需要仔细处理边界条件和各种异常情况的问题
- 需要按照题目要求的步骤依次处理字符串
- 需要注意数值范围的溢出问题

### 2. 具体步骤
1. 跳过前导空格
2. 处理正负号
3. 处理数字字符
4. 处理溢出情况
5. 返回最终结果

### 3. 代码实现
```cpp
class Solution {
public:
    int myAtoi(string s) {
        int i = 0;
        int n = s.length();
        
        // 1. 跳过前导空格
        while (i < n && s[i] == ' ') {
            i++;
        }
        
        // 2. 处理符号
        int sign = 1;
        if (i < n && (s[i] == '+' || s[i] == '-')) {
            sign = (s[i] == '+') ? 1 : -1;
            i++;
        }
        
        // 3. 转换数字
        long result = 0;  // 使用long防止计算过程中溢出
        while (i < n && isdigit(s[i])) {
            result = result * 10 + (s[i] - '0');
            
            // 4. 处理溢出
            if (sign == 1 && result > INT_MAX) {
                return INT_MAX;
            }
            if (sign == -1 && -result < INT_MIN) {
                return INT_MIN;
            }
            
            i++;
        }
        
        // 5. 返回结果
        return sign * result;
    }
};
```

## 复杂度分析
1. **时间复杂度**：O(n)，其中 n 是字符串的长度。我们只需要遍历字符串一次。
2. **空间复杂度**：O(1)，只使用了常数级别的额外空间。

## 扩展问题
### 1. 有效数字
#### 问题描述
验证给定的字符串是否可以解释为十进制数字。

#### 分析
这个问题比 atoi 更复杂，因为需要处理：
1. 科学计数法（例如：e/E）
2. 小数点
3. 正负号的位置

#### 解题思路
1. **初始化状态**：使用布尔变量来跟踪是否已经看到数字、指数和小数点。
2. **遍历字符串**：逐个字符检查字符串：
   - 如果是数字，设置 `seenDigit` 为 `true`。
   - 如果是 `e` 或 `E`，检查是否已经看到过指数，如果没有，则设置 `seenExponent` 为 `true`，并重置 `seenDigit`。
   - 如果是小数点，检查是否已经看到过小数点或指数，如果没有，则设置 `seenDot` 为 `true`。
   - 如果是正负号，检查它是否在有效的位置（如在字符串开头或在 `e` 后面）。
   - 如果遇到其他字符，返回 `false`。
3. **返回结果**：遍历结束后，返回 `seenDigit`，确保至少看到一个数字。

#### 示例
输入：s = "0.1"
输出：true

输入：s = "2e10"
输出：true

#### 代码实现
```cpp
class Solution {
public:
    bool isNumber(string s) {
        bool seenDigit = false;
        bool seenExponent = false;
        bool seenDot = false;
        
        for (int i = 0; i < s.length(); i++) {
            if (isdigit(s[i])) {
                seenDigit = true;
            } else if (s[i] == 'e' || s[i] == 'E') {
                if (seenExponent || !seenDigit) return false;
                seenExponent = true;
                seenDigit = false;
            } else if (s[i] == '.') {
                if (seenDot || seenExponent) return false;
                seenDot = true;
            } else if (s[i] == '+' || s[i] == '-') {
                if (i > 0 && s[i-1] != 'e' && s[i-1] != 'E') return false;
            } else {
                return false;
            }
        }
        
        return seenDigit;
    }
};
```

### 2. 字符串计算器
#### 问题描述
实现一个基本的计算器来计算简单的字符串表达式。

#### 分析
这个问题比 atoi 更进一步，需要处理：
1. 加减运算
2. 括号
3. 空格

#### 解题思路
1. **初始化状态**：使用栈来存储数字和运算符，初始化结果、当前数字和符号。
2. **遍历字符串**：逐个字符检查字符串：
   - 如果是数字，构建当前数字。
   - 如果是运算符（`+` 或 `-`），将当前数字与结果结合，并更新符号。
   - 如果遇到左括号 `(`，将当前结果和符号压入栈中，重置结果和符号。
   - 如果遇到右括号 `)`，将当前数字与结果结合，并从栈中弹出之前的结果和符号，更新结果。
3. **返回结果**：遍历结束后，将最后的数字与结果结合，返回最终结果。

#### 示例
输入：s = "(1+(4+5+2)-3)+(6+8)"
输出：23

#### 代码实现
```cpp
class Solution {
public:
    int calculate(string s) {
        stack<int> nums;
        stack<char> ops;
        int num = 0;
        int result = 0;
        int sign = 1;
        
        for (char c : s) {
            if (isdigit(c)) {
                num = num * 10 + (c - '0');
            } else if (c == '+' || c == '-') {
                result += sign * num;
                num = 0;
                sign = (c == '+') ? 1 : -1;
            } else if (c == '(') {
                nums.push(result);
                ops.push(sign);
                result = 0;
                sign = 1;
            } else if (c == ')') {
                result += sign * num;
                num = 0;
                result = nums.top() + ops.top() * result;
                nums.pop();
                ops.pop();
            }
        }
        
        return result + sign * num;
    }
};
```

## 复杂度分析
- 时间复杂度：O(n)
- 空间复杂度：O(1) 对于 atoi，O(n) 对于计算器（需要栈空间）