## 问题链接
https://leetcode.cn/problems/search-in-rotated-sorted-array/

## 问题描述
整数数组 nums 按升序排列，数组中的值 互不相同 。

在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。

给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。

你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。

### 示例 1：
输入：nums = [4,5,6,7,0,1,2], target = 0
输出：4

### 示例 2：
输入：nums = [4,5,6,7,0,1,2], target = 3
输出：-1

### 示例 3：
输入：nums = [1], target = 0
输出：-1

### 提示：
- 1 <= nums.length <= 5000
- -10^4 <= nums[i] <= 10^4
- nums 中的每个值都 独一无二
- 题目数据保证 nums 在预先未知的某个下标上进行了旋转
- -10^4 <= target <= 10^4

## 解题思路
这道题可以使用改进的二分查找来解决。主要思路如下：

1. 虽然数组被旋转，但是可以发现数组被分成了两个有序的部分。
2. 使用二分查找时，先判断中间元素在哪个有序部分：
   - 如果 nums[left] <= nums[mid]，说明左半部分有序
   - 否则右半部分有序
3. 根据有序部分来判断目标值是否在该范围内：
   - 如果在有序部分的范围内，则在该部分继续二分查找
   - 否则在另一部分查找

## 代码实现
```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0, right = nums.size() - 1;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            
            if (nums[mid] == target) {
                return mid;
            }
            
            // 左半部分有序
            if (nums[left] <= nums[mid]) {
                // 目标值在左半部分
                if (nums[left] <= target && target < nums[mid]) {
                    right = mid - 1;
                } else {
                    left = mid + 1;
                }
            }
            // 右半部分有序
            else {
                // 目标值在右半部分
                if (nums[mid] < target && target <= nums[right]) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
        }
        
        return -1;
    }
};
```

## 复杂度分析
- 时间复杂度：O(log n)，使用二分查找，每次将搜索范围缩小一半。
- 空间复杂度：O(1)，只使用了常数级别的额外空间。

## 优化思路
1. 处理特殊情况：
   - 如果数组为空或长度为0，直接返回-1
   - 如果数组只有一个元素，直接判断是否等于目标值

2. 可以先找到旋转点，然后确定目标值在哪个有序部分，再进行普通的二分查找：
   - 这种方法可能更容易理解，但需要两次二分查找
   - 时间复杂度仍然是 O(log n)


## 扩展问题及解题思路

### 1. 搜索旋转排序数组 II（允许重复元素）
#### 问题描述
已知存在一个按非降序排列的整数数组 nums ，数组中的值不必互不相同。

在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转 ，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [1,1,1,0,1] 在下标 3 处经旋转后可能变为 [1,0,1,1,1] 。

给你 旋转后 的数组 nums 和一个整数 target ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 nums 中存在这个目标值 target ，则返回 true ，否则返回 false 。

#### 解题思路
- 这个问题是原问题的升级版，主要区别在于数组中可能包含重复元素
- 当 nums[left] == nums[mid] 时，无法判断哪部分是有序的。例如：
- 考虑这个数组：[1, 1, 1, 1, 1, 0, 1]
    left 指向索引 0，值为 1
    mid 指向索引 3，值也为 1
- 在这种情况下：
    1. 虽然 nums[left] == nums[mid] == 1，但我们无法确定 0 在左半部分还是右半部分
        左半部分可能是 [1, 1, 1]，完全有序
        右半部分可能是 [1, 0, 1]，不是有序的
    2. 同样的情况也可能相反，比如数组 [1, 0, 1, 1, 1, 1, 1]，此时：
        左半部分是 [1, 0, 1]，不是有序的
        右半部分是 [1, 1, 1]，是有序的
    3. 这就是为什么当 nums[left] == nums[mid] 时，我们无法判断到底哪部分是有序的。这种情况下，我们只能将 left 指针右移一位（left++），继续下一轮判断。
- 解决方案是在遇到 nums[left] == nums[mid] 时，将 left 指针右移一位
- 时间复杂度在最坏情况下（如数组中所有元素相等）会退化到 O(n)


### 3. 旋转数组
#### 问题描述
给你一个数组，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。

例如：
输入: nums = [1,2,3,4,5,6,7], k = 3
输出: [5,6,7,1,2,3,4]

#### 解题思路
1. **数学公式法（最优解）**
- 对于长度为 n 的数组，将数组向右移动 k 位后：
  - 原始位置 i 的元素会移动到新位置 (i + k) % n
  - 或者说，新位置 i 的元素来自于原始位置 (i - k + n) % n
- 时间复杂度：O(n)
- 空间复杂度：O(n)，需要一个临时数组存储结果

2. **翻转数组法（空间优化解）**
- 如果要求空间复杂度 O(1)，可以使用三次翻转：
  1. 首先对整个数组进行翻转
  2. 然后翻转前 k 个元素
  3. 最后翻转剩余的元素

#### 代码实现（数学公式法）
```python
def rotate(nums: List[int], k: int) -> None:
    n = len(nums)
    # 处理 k > n 的情况
    k = k % n
    # 创建临时数组
    temp = nums.copy()
    # 使用数学公式直接计算新位置
    for i in range(n):
        nums[(i + k) % n] = temp[i]
```

#### 代码实现（空间优化解）
```python
def rotate(nums: List[int], k: int) -> None:
    def reverse(nums: List[int], start: int, end: int) -> None:
        while start < end:
            nums[start], nums[end] = nums[end], nums[start]
            start += 1
            end -= 1
    
    n = len(nums)
    k = k % n
    # 1. 翻转整个数组
    reverse(nums, 0, n - 1)
    # 2. 翻转前 k 个元素
    reverse(nums, 0, k - 1)
    # 3. 翻转剩余元素
    reverse(nums, k, n - 1)
```

### 4. 寻找峰值元素
#### 问题描述
峰值元素是指其值严格大于左右相邻值的元素。

给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。

你可以假设 nums[-1] = nums[n] = -∞ 。

你必须实现时间复杂度为 O(log n) 的算法来解决此问题。

#### 解题思路
- 利用二分查找来寻找峰值
- 比较中间元素与其右侧元素：
  - 如果 nums[mid] > nums[mid+1]，说明峰值在左半部分（包括mid）
  - 如果 nums[mid] <= nums[mid+1]，说明峰值在右半部分
- 由于假设边界外的元素为负无穷，所以一定存在峰值
- 时间复杂度为 O(log n)

#### 寻找所有峰值的解法
如果需要找到所有的峰值元素，我们不能使用二分查找方法，而应该使用线性扫描的方法。以下是具体实现思路：

1. **线性扫描法**
```python
def findAllPeaks(nums: List[int]) -> List[int]:
    n = len(nums)
    result = []
    
    # 处理数组长度为1的特殊情况
    if n == 1:
        return [0]  # 根据题意，单个元素也是峰值
        
    # 检查第一个元素是否为峰值
    if nums[0] > nums[1]:
        result.append(0)
        
    # 检查中间的元素
    for i in range(1, n-1):
        if nums[i] > nums[i-1] and nums[i] > nums[i+1]:
            result.append(i)
            
    # 检查最后一个元素是否为峰值
    if nums[n-1] > nums[n-2]:
        result.append(n-1)
        
    return result
```


#### 复杂度分析
- 线性扫描法：
  - 时间复杂度：O(n)，需要遍历整个数组一次
  - 空间复杂度：O(k)，k为峰值的数量

#### 使用场景
1. 如果数据量较小（n < 10^6），使用简单的线性扫描法即可
2. 如果数据量很大，且系统支持并行处理，可以使用分段并行扫描法
3. 如果内存有限，可以使用流式处理，即边扫描边输出峰值

#### 注意事项
1. 处理边界情况：
   - 数组长度为1的情况
   - 第一个和最后一个元素的特殊处理
2. 相等元素的处理：
   - 如果题目要求严格大于，则相等的元素不构成峰值
   - 如果允许等于，需要修改比较条件
3. 并行处理时的边界重叠问题：
   - 需要确保分段处理时不会漏掉或重复计算边界处的峰值

### 关键实现技巧
1. 对于所有这些问题，正确处理边界条件都很重要
2. 二分查找的变体需要特别注意循环条件和指针移动
3. 对于包含重复元素的情况，需要额外的处理逻辑
4. 在实现旋转操作时，要注意处理数组长度为0或1的特殊情况

### 优化建议
1. 在实际应用中，可以添加输入验证
2. 对于大数组，可以考虑并行处理某些操作
3. 在允许使用额外空间的情况下，可以通过哈希表等数据结构优化某些操作
4. 在处理重复元素时，可以通过预处理来提高效率

这些扩展问题展示了如何将基本的二分查找思想应用到各种变体问题中，通过理解和实现这些变体，可以加深对算法设计的理解，提高解决复杂问题的能力。
关键是要注意：
1. 边界条件的处理
2. 如何判断有序部分
3. 如何正确更新搜索范围
4. 特殊情况的处理（如数组为空、只有一个元素等）

通过练习这些相关问题，可以掌握更多二分查找的应用技巧，提高解决算法问题的能力。

