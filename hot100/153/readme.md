# LeetCode 153. 寻找旋转排序数组中的最小值

[LeetCode 153. 寻找旋转排序数组中的最小值](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/)

### 问题描述
给定一个可能存在重复元素的旋转排序数组 `nums`，请找出其中最小的元素。

示例:
输入: `nums = [3,4,5,1,2]`  
输出: `1`

输入: `nums = [4,5,6,7,0,1,2]`  
输出: `0`

### 解题思路
这道题同样可以通过二分查找法来高效解决。我们可以利用旋转排序数组的特性来找到最小值。
1. 有序性：旋转排序数组是由一个已排序的数组经过某个点旋转而成的。这意味着数组的某一部分仍然是有序的。
2. 最小值的位置：最小值一定位于某个有序部分的边界上。也就是说，数组的某一部分是递增的，而最小值则在这两个递增部分之间
### 二分查找法的有效性
1. **初始化指针**：我们使用两个指针 `left` 和 `right`，分别指向数组的开始和结束位置。通过这两个指针，我们可以有效地缩小搜索范围。
  
2. **计算中间位置**：在每次迭代中，我们计算中间位置 `mid`。这个位置将数组分为两部分。

3. **判断关系**：
   - **如果 `nums[mid] < nums[right]`**：这意味着从 `mid` 到 `right` 这一部分是有序的。因为最小值在左半部分或就是 `mid`，所以我们可以将 `right` 更新为 `mid`，缩小搜索范围。
   - **否则**：如果 `nums[mid] >= nums[right]`，这意味着最小值在右半部分，因此我们将 `left` 更新为 `mid + 1`，继续在右半部分查找。

4. **循环结束**：当 `left` 和 `right` 相遇时，`left` 指向的就是最小值。这是因为在每次迭代中，我们都在有效地排除不可能包含最小值的部分。

这种方法的核心在于判断中间元素与右边界元素的关系，从而决定搜索的方向。

### 二分查找法
1. 初始化两个指针 `left` 和 `right`，分别指向数组的开始和结束位置。
2. 进入循环，直到 `left` 超过 `right`：
   - 计算中间位置 `mid = left + (right - left) / 2`。
   - 判断 `nums[mid]` 和 `nums[right]` 的关系：
     - 如果 `nums[mid] < nums[right]`，说明最小值在左半部分或就是 `mid`，更新 `right = mid`。
     - 否则，最小值在右半部分，更新 `left = mid + 1`。
3. 循环结束时，`left` 指向的就是最小值。
使用 left < right 可以确保在循环结束时，left 指向的是最小值的索引。因为在最后一次迭代中，left 会移动到 mid + 1，而 right 会在 mid 处停止，这样 left 就会指向下一个可能的最小值
### 代码实现
```cpp
class Solution {
public:
    int findMin(vector<int>& nums) {
        int left = 0, right = nums.size() - 1;

        while (left < right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < nums[right]) {
                right = mid; // 最小值在左半部分或就是 mid
            } else {
                left = mid + 1; // 最小值在右半部分
            }
        }

        return nums[left]; // 返回最小值
    }
};
```

### 复杂度分析
- 时间复杂度：O(log n)
  - 由于使用了二分查找，每次都将搜索范围减半。
- 空间复杂度：O(1)
  - 只使用了常数额外空间。

### 关键点
1. 利用二分查找的思想来高效查找旋转排序数组中的最小值。
2. 注意判断 `mid` 和 `right` 的关系，以决定搜索的方向。
3. 理解返回值的含义，返回数组中的最小值。