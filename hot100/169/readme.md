````thinking
让我思考一下如何写这篇题解...

首先需要理解LC 169多数元素的核心问题:
- 找出数组中出现次数超过 n/2 的元素
- 这个元素一定存在
- 需要考虑多种解法,从简单到优化

解法思路:
1. 最直观的是排序后取中间元素,因为众数超过n/2必然会占据中间位置
2. 哈希表统计频次
3. Boyer-Moore 投票算法是最优解,很巧妙

需要包含的要点:
- 问题描述要清晰
- 解题思路要由浅入深
- 代码实现要规范
- 复杂度分析要准确

特别是Boyer-Moore算法:
- 核心思想是抵消
- 维护一个候选众数和计数器
- 遇到相同的+1,不同的-1
- 计数器为0时更换候选众数

让我组织一下markdown的结构...
````

# 多数元素

## 问题链接
[LeetCode 169. 多数元素](https://leetcode.com/problems/majority-element/)

## 问题描述
给定一个大小为 n 的数组 nums，返回其中的多数元素。多数元素是指在数组中出现次数 **大于** `⌊ n/2 ⌋` 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

## 解题思路
这道题有多种解法，从简单到优化依次是：

1. 排序法
   - 将数组排序
   - 由于多数元素出现次数超过 n/2，因此排序后的中间元素必定是多数元素
   
2. 哈希表法
   - 使用哈希表统计每个元素出现的次数
   - 找出出现次数大于 n/2 的元素

3. Boyer-Moore 投票算法（最优解）
   - 核心思想：多数元素的出现次数减去其他所有元素的出现次数一定大于0
   - 维护一个候选众数 candidate 和计数器 count
   - 遍历数组时：
     * 当 count 为 0 时，将当前元素设为候选众数
     * 当前元素与候选众数相同则 count+1，不同则 count-1

## 代码实现
```cpp
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        int candidate = nums[0];
        int count = 1;
        
        for (int i = 1; i < nums.size(); i++) {
            if (count == 0) {
                candidate = nums[i];
            }
            count += (nums[i] == candidate) ? 1 : -1;
        }
        
        return candidate;
    }
};
```

## 复杂度分析
以下是 Boyer-Moore 投票算法的复杂度：
- 时间复杂度：O(n)，其中 n 是数组长度，只需要遍历一次数组
- 空间复杂度：O(1)，只使用了常数额外空间
