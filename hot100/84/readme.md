### 柱状图中最大的矩形详解
给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。
求在该柱状图中，能够勾勒出来的矩形的最大面积。

#### 问题本质
本质上是要找到每个柱子能够向左右扩展的最远距离，使得扩展区域内的所有柱子高度都不小于当前柱子的高度。

#### 单调栈解法详解
使用单调栈的原因：
1. 需要找到每个柱子左右两侧第一个比它矮的柱子
2. 单调栈可以在O(n)时间内完成这个任务

#### 算法步骤图解
```
示例：heights = [2,1,5,6,2,3]

步骤1: 初始状态
6 |           __
5 |        __|  |
4 |        |  |  |
3 |        |  |  |    __
2 |  __    |  |  |__ |  |
1 |  |  |__|  |  |  ||  |
0 |__|__|__|__|__|__|__|__
   [2, 1, 5, 6, 2, 3]

处理过程：
1) 遇到2: 入栈 [0]
2) 遇到1: 2>1，计算2的面积
   - 高度=2
   - 宽度=1
   - 面积=2
   入栈 [1]
3) 遇到5: 入栈 [1,2]
4) 遇到6: 入栈 [1,2,3]
5) 遇到2: 6>2，计算6和5的面积
   - 6的面积=6*1=6
   - 5的面积=5*2=10
   入栈 [1,4]
6) 遇到3: 入栈 [1,4,5]

最大面积为10（高度为5，宽度为2的矩形）
```

#### 代码实现要点
```cpp
int largestRectangleArea(vector<int>& heights) {
    // 添加哨兵，简化边界处理
    heights.push_back(0);
    stack<int> st;
    int maxArea = 0;
    
    for (int i = 0; i < heights.size(); i++) {
        // 当前高度小于栈顶高度时，计算栈顶柱子能够形成的最大矩形
        while (!st.empty() && heights[i] < heights[st.top()]) {
            int height = heights[st.top()];
            st.pop();
            
            // 计算宽度：当前位置到栈顶位置的距离
            // 如果栈为空，说明当前竹子是最矮的，左侧没有更矮的，因此宽度可以从0扩展到当前位置i，所以宽度就是i
            // 如果栈不为空，st.top返回的是栈顶元素的索引，表示当前柱子左侧第一个比它矮的柱子，因此宽度就是当前位置i减去栈顶元素的索引再减1
            int width = st.empty() ? i : i - st.top() - 1;
            maxArea = max(maxArea, height * width);
        }
        st.push(i);
    }
    
    return maxArea;
}
```

#### 优化技巧
1. 使用哨兵简化边界处理
   - 在数组末尾添加高度为0的柱子
   - 避免了栈为空的特殊处理

2. 宽度计算技巧
   ```
   当计算某个柱子i能形成的矩形面积时：
   - 右边界：当前遍历到的位置j（第一个比i矮的柱子）
   - 左边界：栈顶元素k（第一个比i矮的柱子）
   - 宽度 = j - k - 1
   ```

3. 特殊情况处理
   ```
   - 单调递增序列：[1,2,3,4,5]
   - 单调递减序列：[5,4,3,2,1]
   - 全部相等：[2,2,2,2]
   ```

#### 复杂度分析
- 时间复杂度：O(n)
  * 每个元素最多入栈和出栈一次
  * 计算面积的操作是常数时间
- 空间复杂度：O(n)
  * 栈在最坏情况下可能存储所有元素（单调递增序列）