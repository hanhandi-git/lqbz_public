```thinking
让我思考一下如何修改这个readme.md来适配LeetCode 438题"找到字符串中所有字母异位词"...

首先我需要:
1. 查看LC 438的具体题目要求和内容
2. 分析解题思路和算法
3. 调整readme.md的结构,保持格式一致但更新内容

LC 438是要在字符串s中找到p的所有字母异位词的起始索引。这是一个滑动窗口的经典题目。

解题思路应该包含:
1. 使用滑动窗口来维护一个长度为p.length()的窗口
2. 用两个数组记录窗口内和目标串p的字符频次
3. 比较两个数组是否相等来判断是否找到异位词
4. 窗口滑动时更新频次数组

我需要:
- 更新问题描述
- 修改解题思路部分
- 给出新的代码实现
- 调整复杂度分析
- 添加具体示例说明

让我开始编写新的内容...
```

# 找到字符串中所有字母异位词
请你修改test.cpp中的算法实现以及测试样子，用于测试readme.md中的算法题

## 问题链接
[LeetCode 438. 找到字符串中所有字母异位词](https://leetcode.com/problems/find-all-anagrams-in-a-string/)

## 问题描述
给定两个字符串 s 和 p，找到 s 中所有 p 的字母异位词的起始索引。返回一个列表，列表中的每个元素都是一个起始索引。

字母异位词指由相同的字母重排列形成的字符串（包括相同的字符串）。

## 解题思路
1. 使用滑动窗口方法来解决这个问题。
2. 维护一个长度为p.length()的窗口，在s上滑动。
3. 使用两个大小为26的数组来记录窗口内和字符串p中各个字符的出现频次。
4. 当窗口内字符频次与p的字符频次完全相同时，找到一个异位词。
5. 随着窗口滑动，更新窗口内字符的频次统计。

### 算法流程
1. 初始化两个大小为26的数组count1和count2，分别统计p和当前窗口内字符的频次。
2. 先统计字符串p中各字符的频次。
3. 初始化一个与p等长的窗口，统计s中前p.length()个字符的频次。
4. 如果两个频次数组相等，则找到第一个异位词。
5. 窗口向右滑动：
   - 移除窗口最左边字符的频次
   - 添加新进入窗口右边字符的频次
   - 比较频次数组是否相等
6. 重复步骤5直到遍历完整个字符串s。

## 代码实现
```cpp
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        if (s.empty() || p.empty() || s.size() < p.size()) return {};
        std::vector<int> need(26, 0);
        std::vector<int> window(26, 0);
        std::vector<int> res;
        int n = p.size();
        // 填充need
        for (char c : p)
        {
            need[c - 'a']++;
        }
        // 填充window
        for (int i = 0; i < n; i++)
        {
            window[s[i] - 'a']++;
        }
        if (window == need) {
            res.push_back(0);
        }
        // 移动窗口
        for (int i = n, j = 1; i < s.size(); i++, j++)
        {
            // out
            window[s[j-1] - 'a']--;
            // in
            window[s[i] - 'a']++;
            if (window == need) {
                res.push_back(j);
            }
        }
        return res;
    }
};
```

## 复杂度分析
- 时间复杂度：O(n)，其中n是字符串s的长度。
- 空间复杂度：O(1)，使用了两个固定大小为26的数组。

## 示例说明
让我们通过一个具体的例子来说明算法的工作过程：

输入：
- s = "cbaebabacd"
- p = "abc"

过程：
1. 初始化：
   - count1记录"abc"中字符频次：[1,1,1,0,...,0]
   - 初始窗口"cba"的count2：[1,1,1,0,...,0]
   - 找到第一个异位词，索引为0

2. 窗口滑动：
   - 移除'c'，添加'e'：[0,1,1,0,1,...,0] (不是异位词)
   - 移除'b'，添加'b'：[0,1,1,0,1,...,0] (不是异位词)
   - 移除'a'，添加'a'：[0,1,1,0,1,...,0] (不是异位词)
   - ...
   - 当窗口移动到"bac"时：[1,1,1,0,...,0]
   - 找到第二个异位词，索引为6

输出：[0,6]

这个例子展示了如何通过滑动窗口和字符频次比较来找到所有的字母异位词。
