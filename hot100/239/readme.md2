```thinking
让我思考一下这个问题...

首先要明确单调队列在这里的作用 - 它维护了一个单调递减的序列。也就是说队列中的元素从前到后是递减的。

为什么要检查back而不是front?

1. 队列的结构:
- front存放的是当前窗口内的最大值的索引
- back存放的是最近加入的元素的索引
- 中间的元素按照值的大小递减排列

2. 新元素加入时的处理逻辑:
- 如果新元素比队尾元素大,说明队尾元素永远不可能成为最大值了
- 因为新元素比它大,而且新元素会在它之后离开窗口
- 所以可以直接把队尾元素弹出
- 继续检查倒数第二个元素,以此类推

3. 如果检查front:
- front是当前窗口最大值
- 新元素不一定比front大
- 即使比front小的元素也可能在front离开窗口后成为最大值
- 所以不能简单地根据与front的大小关系来决定是否保留

举个例子:
nums = [1,3,-1,-3,5,3,6,7], k = 3
当处理到-1时:
队列:[3]
新元素-1比3小,但是不能删除3,因为在3离开窗口前它都是最大值

所以要从back开始检查,保证:
1. 队列严格递减
2. 较小的元素不会占用队列空间
3. 每个元素都有可能在某个时刻成为最大值

这就是为什么要检查back而不是front的原因。
```

这里检查back而不是front是因为单调队列需要维护一个严格递减的序列。从队尾开始检查可以确保:

1. 新加入的元素如果比队尾元素大,那么队尾元素就永远不可能成为窗口的最大值了(因为新元素比它大且会在它之后离开窗口),所以可以直接删除

2. 而队首(front)元素是当前窗口的最大值,即使新元素比它小,这个元素离开窗口后,新元素仍然可能成为最大值,所以不能简单地根据与队首的大小关系来决定是否保留

3. 通过从队尾开始检查并删除较小元素,可以保证队列中的元素始终保持单调递减,这样队首元素就一定是当前窗口的最大值

这种方式既保证了正确性,又提高了效率,因为较小的元素被及时删除,不会占用队列空间。
