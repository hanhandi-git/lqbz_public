```thinking
让我思考一下如何解决LC138复制带随机指针的链表...

关键点：
1. 链表节点除了next指针外还有random指针
2. random指针可以指向任意节点或null
3. 需要深拷贝，即创建全新的节点
4. 要求O(n)时间复杂度

解题思路：
1. 哈希表法
   - 第一次遍历创建所有新节点并建立映射
   - 第二次遍历设置指针关系
2. 原地修改法
   - 在原节点后创建新节点
   - 设置random指针
   - 分离两个链表

需要写清楚：
1. 两种解法的具体步骤
2. 空间复杂度的区别
3. 代码实现的注意事项
4. 边界情况处理
```

# LC138 复制带随机指针的链表

## 问题链接
https://leetcode.cn/problems/copy-list-with-random-pointer/

## 问题描述
给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。

构造这个链表的 深拷贝。深拷贝应该正好由 n 个 全新 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 next 指针和 random 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点。

### 示例 1：
![示例1](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e1.png)
```
输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]
```

### 示例 2：
![示例2](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e2.png)
```
输入：head = [[1,1],[2,1]]
输出：[[1,1],[2,1]]
```

### 示例 3：
![示例3](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e3.png)
```
输入：head = [[3,null],[3,0],[3,null]]
输出：[[3,null],[3,0],[3,null]]
```

### 提示：
- 0 <= n <= 1000
- -10^4 <= Node.val <= 10^4
- Node.random 为 null 或指向链表中的节点

## 解题思路

### 方法一：哈希表法
1. 第一次遍历：
   - 创建所有新节点
   - 使用哈希表建立原节点到新节点的映射关系
2. 第二次遍历：
   - 根据哈希表设置新节点的next和random指针

时间复杂度：O(n)
空间复杂度：O(n)

### 方法二：原地修改法
1. 第一次遍历：
   - 在每个原节点后创建对应的新节点
   - 形如：原1->新1->原2->新2->...
2. 第二次遍历：
   - 设置新节点的random指针
   - 利用 node.next.random = node.random.next
3. 第三次遍历：
   - 分离原链表和新链表
   - 恢复原链表的结构
   - 提取新链表

时间复杂度：O(n)
空间复杂度：O(1)

## 代码实现要点

1. 空指针处理
   - 注意random指针为null的情况
   - 注意链表为空的情况

2. 指针操作
   - 原地修改法中的指针操作要小心
   - 确保不会丢失节点的引用

3. 内存管理
   - 深拷贝需要创建新节点
   - 注意内存泄漏问题

4. 边界情况
   - 空链表
   - 只有一个节点
   - random指向自身

## 复杂度分析

### 方法一：哈希表法
- 时间复杂度：O(n)，需要两次遍历
- 空间复杂度：O(n)，需要哈希表存储映射关系

### 方法二：原地修改法
- 时间复杂度：O(n)，需要三次遍历
- 空间复杂度：O(1)，只使用常数额外空间

## 相关题目
- LC133 克隆图
- LC1485 克隆含随机指针的二叉树
