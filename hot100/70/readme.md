# 爬楼梯

## 问题链接
[LeetCode 70. 爬楼梯](https://leetcode.com/problems/climbing-stairs/)

## 问题描述
假设你正在爬楼梯。需要 n 阶楼梯，你每次可以爬 1 或 2 阶。请问，爬到楼梯顶部有多少种不同的方法？

示例:
输入: `n = 2`
输出: `2`
解释: 有两种方法可以爬到楼梯顶部：
1. 1 阶 + 1 阶
2. 2 阶

输入: `n = 3`
输出: `3`
解释: 有三种方法可以爬到楼梯顶部：
1. 1 阶 + 1 阶 + 1 阶
2. 1 阶 + 2 阶
3. 2 阶 + 1 阶

## 解题思路
这道题可以通过动态规划来解决。我们可以定义一个数组 `dp`，其中 `dp[i]` 表示到达第 `i` 阶楼梯的方法总数。

### 动态规划
1. 初始化 `dp[0] = 1`（到达第 0 阶的方法只有 1 种，即不动）。
2. 初始化 `dp[1] = 1`（到达第 1 阶的方法也只有 1 种，即一步到达）。
3. 对于每个 `i` 从 2 到 `n`，我们可以得到以下递推关系：
   - `dp[i] = dp[i - 1] + dp[i - 2]`
   - 这表示到达第 `i` 阶的方法可以通过到达第 `i-1` 阶再爬 1 阶，或者到达第 `i-2` 阶再爬 2 阶。

4. 最终返回 `dp[n]`，即为到达第 `n` 阶的方法总数。

## 代码实现
```cpp
class Solution {
public:
    int climbStairs(int n) {
        if (n <= 1) return 1;

        vector<int> dp(n + 1);
        dp[0] = 1;
        dp[1] = 1;

        for (int i = 2; i <= n; ++i) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }

        return dp[n]; // 返回到达第 n 阶的方法总数
    }
};
```

基础代码
```cpp
int climbStairs(int n) {
    if (n == 0 ) return 1;
    else if (n <= 1) return n;
    else return climbStairs(n-1) + climbStairs(n-2);
}
```

## 复杂度分析
- 时间复杂度：O(n)
  - 需要遍历到 `n`，计算每个 `dp[i]` 的值。
- 空间复杂度：O(n)
  - 使用了一个大小为 `n + 1` 的数组来存储每个状态。

## 关键点
1. 使用动态规划的思想，利用之前的结果来计算当前的结果。
2. 注意边界条件的处理，确保 `n` 为 0 或 1 时的返回值正确。
3. 理解递推关系，确保 `dp` 数组的更新逻辑正确。
