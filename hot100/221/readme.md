# 最大正方形

## 问题链接
[LeetCode 221. 最大正方形](https://leetcode.com/problems/maximal-square/)

## 问题描述
给你一个由 '0' 和 '1' 组成的二维矩阵 matrix,找出只包含 '1' 的最大正方形,并返回其面积。

示例:
输入:
matrix = [
  ["1","0","1","0","0"],
  ["1","0","1","1","1"],
  ["1","1","1","1","1"],
  ["1","0","0","1","0"]
]
输出: 4

## 解题思路
1. 使用动态规划来解决这个问题:
   - 定义dp[i][j]表示以(i,j)为右下角的最大正方形边长
   - 当前位置是'1'时,其最大正方形边长由其左边、上边和左上三个位置的最小值决定
   - 当前位置是'0'时,最大正方形边长为0
2. 状态转移方程:
   - 当matrix[i][j] = '1'时:
     dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1
   - 当matrix[i][j] = '0'时:
     dp[i][j] = 0
3. 在遍历过程中记录最大的边长,最终返回最大边长的平方即为面积


```thinking
让我深入思考一下这个状态转移方程的本质...

首先,我们要明白dp[i][j]代表的是以(i,j)为右下角的最大正方形边长。那么为什么它取决于左边、上边和左上三个位置的最小值呢?

让我画个图来思考:
假设当前位置是(i,j),要形成一个边长为k的正方形,需要:
1. 左边位置(i,j-1)能形成边长k-1的正方形
2. 上边位置(i-1,j)能形成边长k-1的正方形  
3. 左上位置(i-1,j-1)能形成边长k-1的正方形

为什么需要这三个条件都满足?

啊,我明白了!因为要形成一个正方形,这三个位置都必须能够支撑起相同大小的正方形。如果其中任何一个位置形成的正方形较小,那么当前位置就无法形成更大的正方形。

比如:
- 如果左边只能形成边长2的正方形
- 上边能形成边长3的正方形
- 左上能形成边长4的正方形
那么当前位置最多只能形成边长为3的正方形,因为受限于最小的那个边长2。

所以我们要取这三个位置的最小值,然后加1(因为当前位置本身是'1')。这就解释了为什么状态转移方程是:
dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1

这是一个非常巧妙的设计,通过局部最优解(三个相邻位置的最小值)来构建全局最优解(最大正方形)。
```

这个状态转移方程的设计确实很巧妙。让我来解释为什么是这样的:

1. 要在位置(i,j)形成一个边长为k的正方形,必须同时满足三个条件:
   - 左边(i,j-1)位置必须能形成边长为k-1的正方形
   - 上边(i-1,j)位置必须能形成边长为k-1的正方形
   - 左上(i-1,j-1)位置必须能形成边长为k-1的正方形

2. 这是因为要形成一个完整的正方形:
   - 需要左边有一个完整的竖边
   - 需要上边有一个完整的横边
   - 需要左上区域是一个完整的正方形

3. 如果这三个位置中任何一个位置形成的正方形较小,那么当前位置就会受限于最小的那个,无法形成更大的正方形。

4. 所以我们取三个位置的最小值,再加1(当前位置的'1'),就得到了当前位置能形成的最大正方形边长。

这个方程巧妙地利用了局部最优解来构建全局最优解,是动态规划思想的一个很好的体现。


## 代码实现

```cpp
class Solution {
public:
    int maximalSquare(vector<vector<char>>& matrix) {
        if (matrix.empty() || matrix[0].empty()) return 0;
        
        int m = matrix.size(), n = matrix[0].size();
        vector<vector<int>> dp(m, vector<int>(n, 0));
        int maxSide = 0;
        
        // 初始化第一行和第一列
        for (int i = 0; i < m; i++) {
            if (matrix[i][0] == '1') {
                dp[i][0] = 1;
                maxSide = 1;
            }
        }
        for (int j = 0; j < n; j++) {
            if (matrix[0][j] == '1') {
                dp[0][j] = 1;
                maxSide = 1;
            }
        }
        
        // 动态规划填表
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (matrix[i][j] == '1') {
                    dp[i][j] = min({dp[i-1][j], dp[i][j-1], dp[i-1][j-1]}) + 1;
                    maxSide = max(maxSide, dp[i][j]);
                }
            }
        }
        
        return maxSide * maxSide;
    }
};
```

## 复杂度分析
- 时间复杂度：O(m*n)，其中 m 和 n 分别是矩阵的行数和列数。需要遍历整个矩阵一次。
- 空间复杂度：O(m*n)，需要一个二维dp数组来存储状态。可以优化为O(n),只需要保存上一行的状态。
