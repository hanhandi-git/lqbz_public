## 问题链接
https://leetcode.cn/problems/linked-list-cycle/

## 问题描述
给定一个链表，判断链表中是否有环。为了表示给定链表中的环，我们使用一个整数 pos 来表示链表尾连接到链表中的某个节点。如果 pos 是 -1，则在该链表中没有环。

### 示例 1：

输入：head = [3,2,0,-4], pos = 1  
输出：true  
解释：链表中有一个环，环的起始节点是链表中的第二个节点。

### 示例 2：

输入：head = [1,2], pos = 0  
输出：true  
解释：链表中有一个环，环的起始节点是链表中的第一个节点。

### 示例 3：

输入：head = [1], pos = -1  
输出：false  
解释：链表中没有环。

### 提示：

- 链表中节点的数目范围是 [0, 10^4]。
- -10^5 <= Node.val <= 10^5
- pos 的值为 -1 或者链表中的一个有效索引。

## 解题思路
本题可以使用快慢指针的方法来解决。主要步骤如下：

1. 使用两个指针，快指针（fast）和慢指针（slow）。初始时，两个指针都指向链表的头节点。
2. 快指针每次移动两步，慢指针每次移动一步。
3. 如果链表中存在环，快指针和慢指针最终会相遇；如果不存在环，快指针会到达链表的末尾（nullptr）。

## 代码实现
```cpp
class Solution {
public:
    bool hasCycle(ListNode *head) {
        if (!head) return false; // 如果链表为空，返回 false
        
        ListNode *slow = head;
        ListNode *fast = head;
        
        while (fast && fast->next) {
            slow = slow->next; // 慢指针移动一步
            fast = fast->next->next; // 快指针移动两步
            
            if (slow == fast) { // 如果相遇，说明有环
                return true;
            }
        }
        
        return false; // 如果快指针到达链表末尾，返回 false
    }
};
```

## 复杂度分析
- 时间复杂度：O(n)，其中 n 是链表的长度。快慢指针最多遍历链表两次。
- 空间复杂度：O(1)，只使用了常数级的额外空间。

## 优化思路
1. 可以在遍历过程中加入一些剪枝条件，例如：
   - 如果链表为空，直接返回 false。
   - 如果链表只有一个节点且没有环，直接返回 false。

2. 对于特殊情况的处理：
   - 如果链表长度小于 2，直接返回 false。

通过这些优化，我们可以在某些情况下进一步提高算法的效率。