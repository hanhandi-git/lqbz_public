会议室 II
#### 问题描述
给你一个会议时间安排的数组 intervals ，每个会议时间都会包括开始和结束的时间 [[s1,e1],[s2,e2],...] ，为避免会议冲突，同时要考虑充分利用会议室资源，请你计算至少需要多少间会议室，才能满足这些会议安排。

#### 示例
输入：intervals = [[0,30],[5,10],[15,20]]
输出：2
解释：需要两个会议室
     会议室1：[0,30]
     会议室2：[5,10],[15,20]

#### 解题思路
1. 使用优先队列（最小堆）记录当前正在进行的会议的结束时间
2. 按开始时间排序
3. 遍历每个会议，更新会议室数量
##### 为什么使用优先队列？
1. **数据结构选择原因**：
   - 优先队列（最小堆）能够自动维护最早结束的会议时间
   - O(logn)的插入和删除效率
   - 堆顶始终是当前最早结束的会议时间

2. **算法思路说明**：
   - 我们需要知道当前正在进行的会议中，哪个会议最早结束
   - 当新会议开始时，需要检查是否有会议已经结束
   - 优先队列能高效地维护这个"最早结束时间"

3. **具体工作流程**：
   ```
   输入: [[0,30],[5,10],[15,20]]
   
   处理[0,30]:
   堆: [30]        需要会议室: 1
   
   处理[5,10]:
   堆: [30,10]     需要会议室: 2（因为0,30还未结束）
   
   处理[15,20]:
   堆: [30,20]     需要会议室: 2（10已结束被移除）
   ```

4. **效率分析**：
   - 每个会议时间最多入堆和出堆一次
   - 堆操作的时间复杂度是O(logn)
   - 总体时间复杂度维持在O(nlogn)

5. **相比其他方法的优势**：
   - 不需要遍历所有正在进行的会议
   - 动态维护会议结束时间
   - 空间效率好，只存要的信息

#### 代码实现
```cpp
int minMeetingRooms(vector<vector<int>>& intervals) {
    sort(intervals.begin(), intervals.end());
    priority_queue<int, vector<int>, greater<int>> pq; // 最小堆
    
    for (const auto& interval : intervals) {
        // 移除已经结束的会议
        while (!pq.empty() && pq.top() <= interval[0]) {
            pq.pop();
        }
        // 添加新会议的结束时间
        pq.push(interval[1]);
    }
    
    return pq.size();
}
```