# 数据流的中位数

## 问题链接
[LeetCode 295. 数据流的中位数](https://leetcode.com/problems/find-median-from-data-stream/)

## 问题描述
设计一个支持以下两种操作的数据结构：
1. **添加数字**：向数据流中添加一个整数。
2. **查找中位数**：返回当前数据流的中位数。

中位数是指在排序数组中位于中间的元素。如果数组的长度为偶数，则中位数是中间两个数的平均值。

## 逻辑推导流程
以下是获取数据流中位数的逻辑推导流程：

1. **初始化**：
   - 使用两个优先队列（最大堆和最小堆）来维护数据流的状态。
   - 最大堆用于存储较小的一半元素，最小堆用于存储较大的一半元素。

2. **添加数字**：
   - 将新数字添加到最大堆中。
   - 将最大堆的最大元素（即堆顶元素）移动到最小堆中，以保持两个堆的平衡。
   - 如果最小堆的大小超过最大堆，则将最小堆的最小元素移动到最大堆中。

3. **查找中位数**：
   - 如果最大堆的大小等于最小堆的大小，则中位数为两个堆顶元素的平均值。
   - 如果最大堆的大小大于最小堆，则中位数为最大堆的堆顶元素。

## 解题思路
1. 使用最大堆存储数据流中较小的一半元素。
2. 使用最小堆存储数据流中较大的一半元素。
3. 通过维护两个堆的平衡，快速查找中位数。

## 代码实现
```cpp
class MedianFinder {
public:
    priority_queue<int> maxHeap; // 存储较小的一半元素
    priority_queue<int, vector<int>, greater<int>> minHeap; // 存储较大的一半元素

    /** initialize your data structure here. */
    MedianFinder() {}

    void addNum(int num) {
        maxHeap.push(num); // 将新数字添加到最大堆
        minHeap.push(maxHeap.top()); // 将最大堆的最大元素移动到最小堆
        maxHeap.pop(); // 从最大堆中移除该元素

        // 保持两个堆的平衡
        if (minHeap.size() > maxHeap.size()) {
            maxHeap.push(minHeap.top());
            minHeap.pop();
        }
    }

    double findMedian() {
        if (maxHeap.size() > minHeap.size()) {
            return maxHeap.top(); // 最大堆的堆顶元素为中位数
        } else {
            return (maxHeap.top() + minHeap.top()) / 2.0; // 两个堆顶元素的平均值为中位数
        }
    }
};
```

## 复杂度分析
- 时间复杂度：O(log N)，每次添加数字时需要维护堆的平衡。
- 空间复杂度：O(N)，用于存储两个堆中的元素。

## 示例
假设我们依次添加数字 `1, 2, 3`，我们可以通过上述逻辑得到中位数为 `2`，然后再添加 `4`，此时中位数为 `(2 + 3) / 2 = 2.5`。

### 逻辑推导示例
1. 添加数字 `1`，最大堆为 `[1]`，最小堆为空，中位数为 `1`。
2. 添加数字 `2`，最大堆为 `[1]`，最小堆为 `[2]`，中位数为 `(1 + 2) / 2 = 1.5`。
3. 添加数字 `3`，最大堆为 `[2, 1]`，最小堆为 `[3]`，中位数为 `2`。
4. 添加数字 `4`，最大堆为 `[2, 1]`，最小堆为 `[3, 4]`，中位数为 `(2 + 3) / 2 = 2.5`。
