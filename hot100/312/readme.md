# 气球破裂
请你修改test.cpp中的算法实现以及测试样子，用于测试readme.md中的算法题
## 问题链接
[LeetCode 312. 气球破裂](https://leetcode.com/problems/burst-balloons/)

## 问题描述
有 n 个气球，编号为0 到 n - 1，每个气球上都标有一个数字，这些数字存在数组 nums 中。

现在要求你戳破所有的气球。戳破第 i 个气球，你可以获得 nums[i - 1] * nums[i] * nums[i + 1] 枚硬币。 这里的 i - 1 和 i + 1 代表和 i 相邻的两个气球的序号。如果 i - 1或 i + 1 超出了数组的边界，那么就当它是一个数字为 1 的气球。
求所能获得硬币的最大数量。

## 解题思路
1. 使用动态规划来解决这个问题。
2. 定义 `dp[i][j]` 为在区间 `[i, j]` 内气球的最大得分。
3. 选择一个气球 `k` 来爆破，得分为 `balloons[left - 1] * balloons[k] * balloons[right + 1]`，然后加上 `dp[left][k-1]` 和 `dp[k+1][right]`。
4. 通过遍历所有可能的 `k` 来更新 `dp[i][j]` 的值。
5. 在计算时，注意在数组两端添加虚拟气球，虚拟气球的值为 1。


在这个问题中，我们需要通过动态规划来计算戳破气球所能获得的最大硬币数。推导公式的关键在于理解如何选择一个气球 `k` 来戳破，并计算戳破这个气球所能获得的得分。

### 公式推导解释

1. **气球的得分**：
   - 当我们戳破第 `k` 个气球时，我们获得的得分是与它相邻的两个气球的值的乘积。具体来说，得分为：
     \[
     \text{得分} = \text{balloons}[left - 1] \times \text{balloons}[k] \times \text{balloons}[right + 1]
     \]
   - 这里，`balloons[left - 1]` 是戳破气球 `k` 左边的气球的值，`balloons[k]` 是当前戳破的气球的值，`balloons[right + 1]` 是戳破气球 `k` 右边的气球的值。
   - 如果 `left` 或 `right` 超出了数组的边界，我们在数组两端添加了虚拟气球，其值为 1，因此在边界情况下，得分依然有效。

2. **动态规划的状态转移**：
   - 在戳破气球 `k` 之后，气球 `k` 左边的气球（在区间 `[left, k-1]` 内）和右边的气球（在区间 `[k+1, right]` 内）仍然可以继续戳破。
   - 因此，我们需要加上在戳破气球 `k` 之前，左边和右边气球的最大得分：
     - `dp[left][k-1]` 表示在区间 `[left, k-1]` 内戳破气球所能获得的最大得分。
     - `dp[k+1][right]` 表示在区间 `[k+1, right]` 内戳破气球所能获得的最大得分。

3. **综合得分**：
   - 所以，戳破气球 `k` 的总得分可以表示为：
     \[
     dp[left][right] = \max(dp[left][right], \text{balloons}[left - 1] \times \text{balloons}[k] \times \text{balloons}[right + 1] + dp[left][k - 1] + dp[k + 1][right])
     \]
   - 这里的 `max` 是因为我们需要在所有可能的 `k` 中选择一个，使得得分最大。

### 总结

通过这个公式，我们可以在动态规划的过程中逐步计算出每个区间 `[left, right]` 的最大得分。最终，`dp[1][n]` 就是戳破所有气球所能获得的最大硬币数。这个推导公式的核心在于理解戳破一个气球对周围气球得分的影响，以及如何利用之前计算的结果来构建当前的最大得分。

## 代码实现
```cpp
class Solution {
public:
    int maxCoins(vector<int>& nums) {
        int n = nums.size();
        // 在数组两端添加虚拟气球
        vector<int> balloons(n + 2, 1);
        for (int i = 1; i <= n; i++) {
            balloons[i] = nums[i - 1];
        }
        
        vector<vector<int>> dp(n + 2, vector<int>(n + 2, 0));
        
        // 从小区间到大区间
        for (int length = 1; length <= n; length++) {
            for (int left = 1; left <= n - length + 1; left++) {
                int right = left + length - 1;
                for (int k = left; k <= right; k++) {
                    dp[left][right] = max(dp[left][right], 
                                          balloons[left - 1] * balloons[k] * balloons[right + 1] + 
                                          dp[left][k - 1] + dp[k + 1][right]);
                }
            }
        }
        
        return dp[1][n];
    }
};
```

## 复杂度分析
- 时间复杂度：O(n^3)，其中 n 是气球的数量。
- 空间复杂度：O(n^2)，用于存储动态规划表。


好的，让我们通过一个具体的例子来说明这个动态规划的推导过程。

### 示例

假设我们有一个气球数组 `nums = [3, 1, 5, 8]`。我们需要计算戳破所有气球所能获得的最大硬币数。

#### 步骤 1: 添加虚拟气球

在数组的两端添加虚拟气球，其值为 1。这样，我们的气球数组变为：
```
balloons = [1, 3, 1, 5, 8, 1]
```

#### 步骤 2: 初始化动态规划表

我们定义一个动态规划表 `dp`，其中 `dp[i][j]` 表示在区间 `[i, j]` 内戳破气球所能获得的最大得分。初始化为 0：
```
dp = [
    [0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0]
]
```

#### 步骤 3: 计算得分

我们从小区间开始计算，逐步扩大区间。以下是具体的计算过程：

1. **区间长度为 1**（戳破单个气球）：
   - `dp[1][1] = balloons[0] * balloons[1] * balloons[2] = 1 * 3 * 1 = 3`
   - `dp[2][2] = balloons[1] * balloons[2] * balloons[3] = 3 * 1 * 5 = 15`
   - `dp[3][3] = balloons[2] * balloons[3] * balloons[4] = 1 * 5 * 8 = 40`
   - `dp[4][4] = balloons[3] * balloons[4] * balloons[5] = 5 * 8 * 1 = 40`

   更新后的 `dp` 表：
   ```
   dp = [
       [0, 0, 0, 0, 0, 0],
       [0, 3, 0, 0, 0, 0],
       [0, 0, 15, 0, 0, 0],
       [0, 0, 0, 40, 0, 0],
       [0, 0, 0, 0, 40, 0],
       [0, 0, 0, 0, 0, 0]
   ]
   ```

2. **区间长度为 2**：
   - `dp[1][2]`：戳破气球 1 或 2
     - 如果戳破气球 1：得分 = `1 * 3 * 1 + dp[1][0] + dp[2][2] = 3 + 0 + 15 = 18`
     - 如果戳破气球 2：得分 = `1 * 1 * 5 + dp[1][1] + dp[3][2] = 5 + 3 + 0 = 8`
     - 取最大值：`dp[1][2] = 18`
   - `dp[2][3]`：戳破气球 2 或 3
     - 如果戳破气球 2：得分 = `3 * 1 * 8 + dp[2][1] + dp[3][3] = 24 + 0 + 40 = 64`
     - 如果戳破气球 3：得分 = `3 * 5 * 1 + dp[2][2] + dp[4][3] = 15 + 15 + 0 = 30`
     - 取最大值：`dp[2][3] = 64`
   - `dp[3][4]`：戳破气球 3 或 4
     - 如果戳破气球 3：得分 = `5 * 8 * 1 + dp[3][2] + dp[4][4] = 40 + 0 + 40 = 80`
     - 如果戳破气球 4：得分 = `5 * 1 * 1 + dp[3][3] + dp[5][4] = 5 + 40 + 0 = 45`
     - 取最大值：`dp[3][4] = 80`

   更新后的 `dp` 表：
   ```
   dp = [
       [0, 0, 0, 0, 0, 0],
       [0, 3, 18, 0, 0, 0],
       [0, 0, 15, 64, 0, 0],
       [0, 0, 0, 40, 80, 0],
       [0, 0, 0, 0, 40, 0],
       [0, 0, 0, 0, 0, 0]
   ]
   ```

3. **区间长度为 3**：
   - `dp[1][3]`：戳破气球 1、2 或 3
     - 如果戳破气球 1：得分 = `1 * 3 * 8 + dp[1][0] + dp[2][3] = 24 + 0 + 64 = 88`
     - 如果戳破气球 2：得分 = `1 * 1 * 8 + dp[1][1] + dp[3][3] = 8 + 3 + 40 = 51`
     - 如果戳破气球 3：得分 = `1 * 5 * 1 + dp[1][2] + dp[4][3] = 5 + 18 + 0 = 23`
     - 取最大值：`dp[1][3] = 88`
   - `dp[2][4]`：戳破气球 2、3 或 4
     - 如果戳破气球 2：得分 = `3 * 1 * 1 + dp[2][1] + dp[3][4] = 3 + 0 + 80 = 83`
     - 如果戳破气球 3：得分 = `3 * 5 * 1 + dp[2][2] + dp[4][4] = 15 + 15 + 40 = 70`
     - 如果戳破气球 4：得分 = `3 * 8 * 1 + dp[2][3] + dp[5][4] = 24 + 64 + 0 = 88`
     - 取最大值：`dp[2][4] = 88`

   更新后的 `dp` 表：
   ```
   dp = [
       [0, 0, 0, 0, 0, 0],
       [0, 3, 18, 88, 0, 0],
       [0, 0, 15, 64, 88, 0],
       [0, 0, 0, 40, 80, 0],
       [0, 0, 0, 0, 40, 0],
       [0, 0, 0, 0, 0, 0]
   ]
   ```

4. **区间长度为 4**（完整数组）：
   - `dp[1][4]`：戳破气球 1、2、3 或 4
     - 如果戳破气球 1：得分 = `1 * 3 * 1 + dp[1][0] + dp[2][4] = 3 + 0 + 88 = 91`
     - 如果戳破气球 2：得分 = `1 * 1 * 1 + dp[1][1] + dp[3][4] = 1 + 3 + 80 = 84`
     - 如果戳破气球 3：得分 = `1 * 5 * 1 + dp[1][2] + dp[4][4] = 5 + 18 + 40 = 63`
     - 如果戳破气球 4：得分 = `1 * 8 * 1 + dp[1][3] + dp[5][4] = 8 + 88 + 0 = 96`
     - 取最大值：`dp[1][4] = 96`

最终的 `dp` 表：
```
dp = [
    [0, 0, 0, 0, 0, 0],
    [0, 3, 18, 88, 96],
    [0, 0, 15, 64, 88],
    [0, 0, 0, 40, 80],
    [0, 0, 0, 0, 40],
    [0, 0, 0, 0, 0]
]
```

### 结果

最终，`dp[1][4]` 的值为 96，这就是戳破所有气球所能获得的最大硬币数。

### 总结

通过这个例子，我们可以看到如何使用动态规划来逐步计算每个区间的最大得分，并最终得到戳破所有气球的最大得分。每一步都利用了之前计算的结果，确保了计算的高效性。
