# 最佳买卖股票时机含冷冻期

## 问题链接
[LeetCode 309. 最佳买卖股票时机含冷冻期](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

## 问题描述
给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格。

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:
- 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
- 卖出股票后，你无法在第二天买入股票（即冷冻期为 1 天）。

## 逻辑推导流程
以下是求解股票问题含冷冻期的逻辑推导流程：

1. **状态定义**：
   - 我们可以将任意一天定义为三种状态之一：
     - 持有股票状态（hold）：当前持有股票的最大利润
     - 不持有股票且处于冷冻期（sold）：当天卖出股票后的最大利润
     - 不持有股票且不处于冷冻期（reset）：不持有股票且不在冷冻期的最大利润

2. **状态转移**：
   - hold[i]：第i天持有股票的最大利润
     - 可能是前一天就持有股票：hold[i-1]
     - 可能是当天买入（前一天不持有且不在冷冻期）：reset[i-1] - prices[i]
     - hold[i] = max(hold[i-1], reset[i-1] - prices[i])
   
   - sold[i]：第i天卖出股票的最大利润
     - 只能是前一天持有股票，当天卖出：hold[i-1] + prices[i]
     - sold[i] = hold[i-1] + prices[i]
   
   - reset[i]：第i天不持有股票且不在冷冻期的最大利润
     - 可能是前一天也不持有股票且不在冷冻期：reset[i-1]
     - 可能是前一天刚卖出，度过冷冻期：sold[i-1]
     - reset[i] = max(reset[i-1], sold[i-1])

3. **初始状态**：
   - hold[0] = -prices[0]：第一天买入股票
   - sold[0] = 0：第一天不可能卖出股票
   - reset[0] = 0：第一天不操作

4. **结果**：
   - 最终最大利润是最后一天不持有股票的最大利润，即max(sold[n-1], reset[n-1])

## 解题思路
1. 使用动态规划，定义三种状态并实现状态转移。
2. 由于当前状态只依赖于前一天的状态，可以使用滚动变量优化空间。

## 代码实现
```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        if (n <= 1) return 0;
        
        // 初始化三种状态
        int hold = -prices[0]; // 持有股票
        int sold = 0;          // 卖出股票（冷冻期）
        int reset = 0;         // 不持有股票且不在冷冻期
        
        for (int i = 1; i < n; i++) {
            int prevHold = hold;
            int prevSold = sold;
            int prevReset = reset;
            
            // 状态转移
            hold = max(prevHold, prevReset - prices[i]);
            sold = prevHold + prices[i];
            reset = max(prevReset, prevSold);
        }
        
        // 最大利润是最后一天不持有股票的最大值
        return max(sold, reset);
    }
};
```

## 优化解法
上述代码已经是优化后的版本，使用滚动变量替代了数组，将空间复杂度从O(n)优化到O(1)。

## 复杂度分析
- 时间复杂度：O(n)，其中n是数组的长度，我们只需要遍历一次数组。
- 空间复杂度：O(1)，只使用了常数额外空间。

## 示例
假设输入数组为 `[1, 2, 3, 0, 2]`，最大利润为 3。

### 逻辑推导示例
1. 初始状态：hold = -1, sold = 0, reset = 0
2. 第2天（价格=2）：
   - hold = max(-1, 0-2) = -1 （保持持有或买入）
   - sold = -1 + 2 = 1 （卖出）
   - reset = max(0, 0) = 0 （保持不持有或度过冷冻期）
3. 第3天（价格=3）：
   - hold = max(-1, 0-3) = -1 （保持持有或买入）
   - sold = -1 + 3 = 2 （卖出）
   - reset = max(0, 1) = 1 （保持不持有或度过冷冻期）
4. 第4天（价格=0）：
   - hold = max(-1, 1-0) = 1 （保持持有或买入）
   - sold = -1 + 0 = -1 （卖出）
   - reset = max(1, 2) = 2 （保持不持有或度过冷冻期）
5. 第5天（价格=2）：
   - hold = max(1, 2-2) = 1 （保持持有或买入）
   - sold = 1 + 2 = 3 （卖出）
   - reset = max(2, -1) = 2 （保持不持有或度过冷冻期）

最终结果是max(sold, reset) = max(3, 2) = 3。

这表示最佳策略是：第1天买入（价格=1），第3天卖出（价格=3），第4天买入（价格=0），第5天卖出（价格=2），总利润为(3-1)+(2-0)=4-0=3。