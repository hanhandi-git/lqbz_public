```thinking
让我思考一下如何修改这个readme.md来适配LeetCode 560题"和为K的子数组"...

首先我需要:
1. 查看LC 560的具体题目要求和内容
2. 分析解题思路和算法
3. 调整readme.md的结构,保持格式一致但更新内容

LC 560是要求给定一个整数数组和一个整数k,找到总和等于k的连续子数组的个数。这是一个前缀和+哈希表的经典题目。

解题思路应该包含:
1. 使用前缀和数组来快速计算任意区间和
2. 用哈希表优化查找过程
3. 遍历前缀和,查找(preSum - k)出现的次数
4. 累加符合条件的子数组个数

我需要:
- 更新问题描述
- 修改解题思路部分
- 给出新的代码实现
- 调整复杂度分析
- 添加具体示例说明

让我开始编写新的内容...
```

````markdown:hot100/560/readme.md
# 和为K的子数组
请你修改test.cpp中的算法实现以及测试样例，用于测试readme.md中的算法题

## 问题链接
[LeetCode 560. 和为K的子数组](https://leetcode.com/problems/subarray-sum-equals-k/)

## 问题描述
给你一个整数数组 nums 和一个整数 k ，请你统计并返回该数组中和为 k 的连续子数组的个数。

## 解题思路
1. 使用前缀和 + 哈希表的方法来解决这个问题。
2. 前缀和数组preSum[i]表示nums[0]到nums[i]的累加和。
3. 对于每个位置i,如果存在一个位置j使得preSum[i] - preSum[j] = k,则说明nums[j+1]到nums[i]的和为k。
4. 使用哈希表来存储每个前缀和出现的次数,优化查找过程。

### 算法流程
1. 初始化哈希表mp,用于存储前缀和出现的次数,初始化mp[0] = 1。
2. 维护当前的前缀和preSum。
3. 遍历数组nums:
   - 更新前缀和preSum += nums[i]
   - 在哈希表中查找是否存在preSum - k
   - 将当前前缀和加入哈希表
4. 返回累计的子数组个数。

## 代码实现
```cpp
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        unordered_map<int, int> mp;     // 用于存储前缀和及其出现次数
        mp[0] = 1;  // 初始化时将前缀和为0的出现次数设为1   // 这是为了处理从数组起始位置开始的子数组之和等于k的情况
        int count = 0;  // 记录满足条件的子数组个数
        int preSum = 0; // 当前位置的前缀和
        
        for (int num : nums) {
            preSum += num;  // 更新当前的前缀和
            if (mp.find(preSum - k) != mp.end()) {  // 查找是否存在 preSum-k 的前缀和
                count += mp[preSum - k];// 将找到的所有符合条件的子数组个数加到结果中
            }
            mp[preSum]++;// 将当前前缀和加入哈希表或更新其出现次数
        }
        
        return count;
    }
};
```

## 复杂度分析
- 时间复杂度：O(n)，其中n是数组nums的长度。
- 空间复杂度：O(n)，哈希表在最坏情况下可能需要存储n个不同的前缀和。

## 示例说明
让我们通过一个具体的例子来说明算法的工作过程：

输入：
- nums = [1,1,1]
- k = 2

过程：
1. 初始化：
   - mp = {0:1}
   - preSum = 0
   - count = 0

2. 遍历数组：
   - i = 0:
     * preSum = 1
     * 查找mp[1-2] = mp[-1]不存在
     * mp = {0:1, 1:1}
   
   - i = 1:
     * preSum = 2
     * 查找mp[2-2] = mp[0] = 1
     * count = 1
     * mp = {0:1, 1:1, 2:1}
   
   - i = 2:
     * preSum = 3
     * 查找mp[3-2] = mp[1] = 1
     * count = 2
     * mp = {0:1, 1:1, 2:1, 3:1}

输出：2

这个例子展示了如何通过前缀和和哈希表来找到所有和为k的连续子数组。
```
