# ES中的评分机制详解

## 概述
Elasticsearch默认使用BM25算法进行相关性评分，这是对经典的TF-IDF算法的改进版本。评分机制主要考虑以下几个关键因素：文档频率、词频、字段长度等。

## 核心评分因素

### 1. TF（词频，Term Frequency）
- 定义：词条在文档中出现的频率
- 计算公式：
```
TF = freq / (freq + k1 * (1 - b + b * dl/avgdl))
```
其中：
- freq: 词条在文档中的出现次数
- k1: 词频饱和参数（默认1.2）
- b: 字段长度归一化参数（默认0.75）
- dl: 当前文档字段长度
- avgdl: 平均文档字段长度

### 2. IDF（逆文档频率，Inverse Document Frequency）
- 定义：衡量词条的重要性
- 计算公式：
```
IDF = ln(1 + (N - n + 0.5)/(n + 0.5))
```
其中：
- N: 索引中的文档总数
- n: 包含该词条的文档数

#### IDF公式设计原理

1. **基本思想**
   - 词条在越少的文档中出现，其区分度就越高
   - 比如"的"这个词在几乎所有文档中都出现，其IDF值应该很低
   - 而"elasticsearch"这样的专业词汇出现较少，其IDF值应该较高

2. **公式演进**
   - 最初的IDF公式：`IDF = ln(N/n)`
   - BM25改进的IDF公式：`IDF = ln(1 + (N - n + 0.5)/(n + 0.5))`

3. **改进说明**
   - 加入0.5的平滑因子：避免n=0时的无穷大问题
   - 使用(N-n)：更好地反映词条的稀有程度
   - 加1：确保IDF值始终为正数

4. **特点分析**
   - 当n接近N时（常见词），IDF趋近于0
   - 当n很小时（罕见词），IDF值较大
   - 平滑处理使得极端情况下的评分更合理

5. **数值示例**
```
假设文档总数N=1000：

常见词：
- n=900（90%文档包含）
IDF = ln(1 + (1000-900+0.5)/(900+0.5)) ≈ 0.11

中等频率词：
- n=100（10%文档包含）
IDF = ln(1 + (1000-100+0.5)/(100+0.5)) ≈ 2.25

罕见词：
- n=10（1%文档包含）
IDF = ln(1 + (1000-10+0.5)/(10+0.5)) ≈ 4.62
```

#### IDF在实际应用中的意义

1. **文档相关性**
   - 帮助识别文档中的关键词
   - 降低常见词的权重
   - 提升具有区分度词条的重要性

2. **搜索优化**
   - 提高搜索结果的精确度
   - 使罕见但相关的文档能够排在前面
   - 避免常见词干扰搜索结果

3. **业务场景应用**
   - 专业领域搜索：专业术语具有较高IDF值
   - 新闻搜索：热点词汇IDF值会随时间变化
   - 商品搜索：品牌名称通常具有较高IDF值

### 3. 字段长度归一化
- 目的：平衡字段长度对评分的影响
- 较短的字段通常得分较高
- 通过参数b控制归一化强度

## BM25评分公式

最终的评分计算公式：
```
score = IDF * TF * boost * lengthNorm
```

其中：
- boost: 字段权重提升值
- lengthNorm: 字段长度归一化因子

## 自定义评分

### 1. 字段权重调整
```json
{
  "query": {
    "match": {
      "title": {
        "query": "搜索词",
        "boost": 2.0
      }
    }
  }
}
```

### 2. function_score查询
```json
{
  "query": {
    "function_score": {
      "query": { "match_all": {} },
      "functions": [
        {
          "field_value_factor": {
            "field": "popularity",
            "factor": 1.2,
            "modifier": "log1p"
          }
        }
      ],
      "boost_mode": "multiply"
    }
  }
}
```

### 3. 脚本评分
```json
{
  "query": {
    "script_score": {
      "query": { "match_all": {} },
      "script": {
        "source": "doc['likes'].value * params.factor",
        "params": {
          "factor": 1.2
        }
      }
    }
  }
}
```

## 评分调优建议

1. **合理设置boost值**
   - 重要字段给予更高的boost
   - 避免boost值差异过大

2. **使用function_score**
   - 结合业务指标（如点击率、销量）
   - 使用合适的boost_mode和score_mode

3. **字段长度归一化**
   - 根据业务需求调整b参数
   - 考虑是否需要禁用归一化

4. **分词优化**
   - 选择适的分词器
   - 考虑同义词扩展

## 注意事项

1. **性能考虑**
   - 复杂的评分计算会影响查询性能
   - 避免使用过于复杂的脚本评分

2. **评分调试**
   - 使用explain API分析评分过程
   - 通过测试数据验证评分效果

3. **版本差异**
   - ES 5.0之前默认使用TF-IDF
   - ES 5.0之后默认使用BM25

## 总结

ES的评分机制是一个复杂但灵活的系统，通过理解其核心原理和合理使用各种评分调优手段，可以实现更精准的搜索结果排序。在实际应用中，需要根据具体业务需求来调整和优化评分策略。
